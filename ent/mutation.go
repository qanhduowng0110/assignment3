// Code generated by ent, DO NOT EDIT.

package ent

import (
	"assignment3/ent/associatedevent"
	"assignment3/ent/earthquake"
	"assignment3/ent/location"
	"assignment3/ent/magnitude"
	"assignment3/ent/predicate"
	"assignment3/ent/request"
	"assignment3/ent/role"
	"assignment3/ent/schemamigration"
	enttime "assignment3/ent/time"
	"assignment3/ent/type_eathquake"
	"assignment3/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAssociatedEvent = "AssociatedEvent"
	TypeEarthquake      = "Earthquake"
	TypeLocation        = "Location"
	TypeMagnitude       = "Magnitude"
	TypeRequest         = "Request"
	TypeRole            = "Role"
	TypeSchemaMigration = "SchemaMigration"
	TypeTime            = "Time"
	TypeTypeEathquake   = "Type_eathquake"
	TypeUser            = "User"
)

// AssociatedEventMutation represents an operation that mutates the AssociatedEvent nodes in the graph.
type AssociatedEventMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	earthquake        *int
	clearedearthquake bool
	done              bool
	oldValue          func(context.Context) (*AssociatedEvent, error)
	predicates        []predicate.AssociatedEvent
}

var _ ent.Mutation = (*AssociatedEventMutation)(nil)

// associatedeventOption allows management of the mutation configuration using functional options.
type associatedeventOption func(*AssociatedEventMutation)

// newAssociatedEventMutation creates new mutation for the AssociatedEvent entity.
func newAssociatedEventMutation(c config, op Op, opts ...associatedeventOption) *AssociatedEventMutation {
	m := &AssociatedEventMutation{
		config:        c,
		op:            op,
		typ:           TypeAssociatedEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssociatedEventID sets the ID field of the mutation.
func withAssociatedEventID(id int) associatedeventOption {
	return func(m *AssociatedEventMutation) {
		var (
			err   error
			once  sync.Once
			value *AssociatedEvent
		)
		m.oldValue = func(ctx context.Context) (*AssociatedEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssociatedEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssociatedEvent sets the old AssociatedEvent of the mutation.
func withAssociatedEvent(node *AssociatedEvent) associatedeventOption {
	return func(m *AssociatedEventMutation) {
		m.oldValue = func(context.Context) (*AssociatedEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssociatedEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssociatedEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AssociatedEvent entities.
func (m *AssociatedEventMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssociatedEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssociatedEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AssociatedEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEarthquakeID sets the "earthquake_id" field.
func (m *AssociatedEventMutation) SetEarthquakeID(i int) {
	m.earthquake = &i
}

// EarthquakeID returns the value of the "earthquake_id" field in the mutation.
func (m *AssociatedEventMutation) EarthquakeID() (r int, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEarthquakeID returns the old "earthquake_id" field's value of the AssociatedEvent entity.
// If the AssociatedEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssociatedEventMutation) OldEarthquakeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarthquakeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarthquakeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarthquakeID: %w", err)
	}
	return oldValue.EarthquakeID, nil
}

// ClearEarthquakeID clears the value of the "earthquake_id" field.
func (m *AssociatedEventMutation) ClearEarthquakeID() {
	m.earthquake = nil
	m.clearedFields[associatedevent.FieldEarthquakeID] = struct{}{}
}

// EarthquakeIDCleared returns if the "earthquake_id" field was cleared in this mutation.
func (m *AssociatedEventMutation) EarthquakeIDCleared() bool {
	_, ok := m.clearedFields[associatedevent.FieldEarthquakeID]
	return ok
}

// ResetEarthquakeID resets all changes to the "earthquake_id" field.
func (m *AssociatedEventMutation) ResetEarthquakeID() {
	m.earthquake = nil
	delete(m.clearedFields, associatedevent.FieldEarthquakeID)
}

// SetCreatedAt sets the "created_at" field.
func (m *AssociatedEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssociatedEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssociatedEvent entity.
// If the AssociatedEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssociatedEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AssociatedEventMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[associatedevent.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AssociatedEventMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[associatedevent.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssociatedEventMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, associatedevent.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssociatedEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssociatedEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssociatedEvent entity.
// If the AssociatedEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssociatedEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AssociatedEventMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[associatedevent.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AssociatedEventMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[associatedevent.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssociatedEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, associatedevent.FieldUpdatedAt)
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *AssociatedEventMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[associatedevent.FieldEarthquakeID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *AssociatedEventMutation) EarthquakeCleared() bool {
	return m.EarthquakeIDCleared() || m.clearedearthquake
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *AssociatedEventMutation) EarthquakeIDs() (ids []int) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *AssociatedEventMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// Where appends a list predicates to the AssociatedEventMutation builder.
func (m *AssociatedEventMutation) Where(ps ...predicate.AssociatedEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssociatedEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssociatedEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AssociatedEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssociatedEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssociatedEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AssociatedEvent).
func (m *AssociatedEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssociatedEventMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.earthquake != nil {
		fields = append(fields, associatedevent.FieldEarthquakeID)
	}
	if m.created_at != nil {
		fields = append(fields, associatedevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, associatedevent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssociatedEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case associatedevent.FieldEarthquakeID:
		return m.EarthquakeID()
	case associatedevent.FieldCreatedAt:
		return m.CreatedAt()
	case associatedevent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssociatedEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case associatedevent.FieldEarthquakeID:
		return m.OldEarthquakeID(ctx)
	case associatedevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case associatedevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AssociatedEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssociatedEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case associatedevent.FieldEarthquakeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarthquakeID(v)
		return nil
	case associatedevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case associatedevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssociatedEventMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssociatedEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssociatedEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssociatedEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssociatedEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(associatedevent.FieldEarthquakeID) {
		fields = append(fields, associatedevent.FieldEarthquakeID)
	}
	if m.FieldCleared(associatedevent.FieldCreatedAt) {
		fields = append(fields, associatedevent.FieldCreatedAt)
	}
	if m.FieldCleared(associatedevent.FieldUpdatedAt) {
		fields = append(fields, associatedevent.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssociatedEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssociatedEventMutation) ClearField(name string) error {
	switch name {
	case associatedevent.FieldEarthquakeID:
		m.ClearEarthquakeID()
		return nil
	case associatedevent.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case associatedevent.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssociatedEventMutation) ResetField(name string) error {
	switch name {
	case associatedevent.FieldEarthquakeID:
		m.ResetEarthquakeID()
		return nil
	case associatedevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case associatedevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssociatedEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquake != nil {
		edges = append(edges, associatedevent.EdgeEarthquake)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssociatedEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case associatedevent.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssociatedEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssociatedEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssociatedEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquake {
		edges = append(edges, associatedevent.EdgeEarthquake)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssociatedEventMutation) EdgeCleared(name string) bool {
	switch name {
	case associatedevent.EdgeEarthquake:
		return m.clearedearthquake
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssociatedEventMutation) ClearEdge(name string) error {
	switch name {
	case associatedevent.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssociatedEventMutation) ResetEdge(name string) error {
	switch name {
	case associatedevent.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	}
	return fmt.Errorf("unknown AssociatedEvent edge %s", name)
}

// EarthquakeMutation represents an operation that mutates the Earthquake nodes in the graph.
type EarthquakeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	url                      *string
	status                   *string
	tsunami                  *int32
	addtsunami               *int32
	net                      *string
	code                     *string
	sources                  *string
	nst                      *int
	addnst                   *int
	dmin                     *float64
	adddmin                  *float64
	rms                      *float64
	addrms                   *float64
	gap                      *float64
	addgap                   *float64
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	associated_events        map[int]struct{}
	removedassociated_events map[int]struct{}
	clearedassociated_events bool
	location                 *int
	clearedlocation          bool
	magnitude                *int
	clearedmagnitude         bool
	time                     *int
	clearedtime              bool
	types                    map[int]struct{}
	removedtypes             map[int]struct{}
	clearedtypes             bool
	done                     bool
	oldValue                 func(context.Context) (*Earthquake, error)
	predicates               []predicate.Earthquake
}

var _ ent.Mutation = (*EarthquakeMutation)(nil)

// earthquakeOption allows management of the mutation configuration using functional options.
type earthquakeOption func(*EarthquakeMutation)

// newEarthquakeMutation creates new mutation for the Earthquake entity.
func newEarthquakeMutation(c config, op Op, opts ...earthquakeOption) *EarthquakeMutation {
	m := &EarthquakeMutation{
		config:        c,
		op:            op,
		typ:           TypeEarthquake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEarthquakeID sets the ID field of the mutation.
func withEarthquakeID(id int) earthquakeOption {
	return func(m *EarthquakeMutation) {
		var (
			err   error
			once  sync.Once
			value *Earthquake
		)
		m.oldValue = func(ctx context.Context) (*Earthquake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Earthquake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEarthquake sets the old Earthquake of the mutation.
func withEarthquake(node *Earthquake) earthquakeOption {
	return func(m *EarthquakeMutation) {
		m.oldValue = func(context.Context) (*Earthquake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EarthquakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EarthquakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Earthquake entities.
func (m *EarthquakeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EarthquakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EarthquakeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Earthquake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLocationID sets the "location_id" field.
func (m *EarthquakeMutation) SetLocationID(i int) {
	m.location = &i
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *EarthquakeMutation) LocationID() (r int, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ClearLocationID clears the value of the "location_id" field.
func (m *EarthquakeMutation) ClearLocationID() {
	m.location = nil
	m.clearedFields[earthquake.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *EarthquakeMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *EarthquakeMutation) ResetLocationID() {
	m.location = nil
	delete(m.clearedFields, earthquake.FieldLocationID)
}

// SetTimeID sets the "time_id" field.
func (m *EarthquakeMutation) SetTimeID(i int) {
	m.time = &i
}

// TimeID returns the value of the "time_id" field in the mutation.
func (m *EarthquakeMutation) TimeID() (r int, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeID returns the old "time_id" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldTimeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeID: %w", err)
	}
	return oldValue.TimeID, nil
}

// ClearTimeID clears the value of the "time_id" field.
func (m *EarthquakeMutation) ClearTimeID() {
	m.time = nil
	m.clearedFields[earthquake.FieldTimeID] = struct{}{}
}

// TimeIDCleared returns if the "time_id" field was cleared in this mutation.
func (m *EarthquakeMutation) TimeIDCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldTimeID]
	return ok
}

// ResetTimeID resets all changes to the "time_id" field.
func (m *EarthquakeMutation) ResetTimeID() {
	m.time = nil
	delete(m.clearedFields, earthquake.FieldTimeID)
}

// SetMagitudeID sets the "magitude_id" field.
func (m *EarthquakeMutation) SetMagitudeID(i int) {
	m.magnitude = &i
}

// MagitudeID returns the value of the "magitude_id" field in the mutation.
func (m *EarthquakeMutation) MagitudeID() (r int, exists bool) {
	v := m.magnitude
	if v == nil {
		return
	}
	return *v, true
}

// OldMagitudeID returns the old "magitude_id" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldMagitudeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagitudeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagitudeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagitudeID: %w", err)
	}
	return oldValue.MagitudeID, nil
}

// ClearMagitudeID clears the value of the "magitude_id" field.
func (m *EarthquakeMutation) ClearMagitudeID() {
	m.magnitude = nil
	m.clearedFields[earthquake.FieldMagitudeID] = struct{}{}
}

// MagitudeIDCleared returns if the "magitude_id" field was cleared in this mutation.
func (m *EarthquakeMutation) MagitudeIDCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldMagitudeID]
	return ok
}

// ResetMagitudeID resets all changes to the "magitude_id" field.
func (m *EarthquakeMutation) ResetMagitudeID() {
	m.magnitude = nil
	delete(m.clearedFields, earthquake.FieldMagitudeID)
}

// SetURL sets the "url" field.
func (m *EarthquakeMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *EarthquakeMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *EarthquakeMutation) ClearURL() {
	m.url = nil
	m.clearedFields[earthquake.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *EarthquakeMutation) URLCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *EarthquakeMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, earthquake.FieldURL)
}

// SetStatus sets the "status" field.
func (m *EarthquakeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EarthquakeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EarthquakeMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[earthquake.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EarthquakeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EarthquakeMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, earthquake.FieldStatus)
}

// SetTsunami sets the "tsunami" field.
func (m *EarthquakeMutation) SetTsunami(i int32) {
	m.tsunami = &i
	m.addtsunami = nil
}

// Tsunami returns the value of the "tsunami" field in the mutation.
func (m *EarthquakeMutation) Tsunami() (r int32, exists bool) {
	v := m.tsunami
	if v == nil {
		return
	}
	return *v, true
}

// OldTsunami returns the old "tsunami" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldTsunami(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTsunami is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTsunami requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTsunami: %w", err)
	}
	return oldValue.Tsunami, nil
}

// AddTsunami adds i to the "tsunami" field.
func (m *EarthquakeMutation) AddTsunami(i int32) {
	if m.addtsunami != nil {
		*m.addtsunami += i
	} else {
		m.addtsunami = &i
	}
}

// AddedTsunami returns the value that was added to the "tsunami" field in this mutation.
func (m *EarthquakeMutation) AddedTsunami() (r int32, exists bool) {
	v := m.addtsunami
	if v == nil {
		return
	}
	return *v, true
}

// ClearTsunami clears the value of the "tsunami" field.
func (m *EarthquakeMutation) ClearTsunami() {
	m.tsunami = nil
	m.addtsunami = nil
	m.clearedFields[earthquake.FieldTsunami] = struct{}{}
}

// TsunamiCleared returns if the "tsunami" field was cleared in this mutation.
func (m *EarthquakeMutation) TsunamiCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldTsunami]
	return ok
}

// ResetTsunami resets all changes to the "tsunami" field.
func (m *EarthquakeMutation) ResetTsunami() {
	m.tsunami = nil
	m.addtsunami = nil
	delete(m.clearedFields, earthquake.FieldTsunami)
}

// SetNet sets the "net" field.
func (m *EarthquakeMutation) SetNet(s string) {
	m.net = &s
}

// Net returns the value of the "net" field in the mutation.
func (m *EarthquakeMutation) Net() (r string, exists bool) {
	v := m.net
	if v == nil {
		return
	}
	return *v, true
}

// OldNet returns the old "net" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldNet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNet: %w", err)
	}
	return oldValue.Net, nil
}

// ClearNet clears the value of the "net" field.
func (m *EarthquakeMutation) ClearNet() {
	m.net = nil
	m.clearedFields[earthquake.FieldNet] = struct{}{}
}

// NetCleared returns if the "net" field was cleared in this mutation.
func (m *EarthquakeMutation) NetCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldNet]
	return ok
}

// ResetNet resets all changes to the "net" field.
func (m *EarthquakeMutation) ResetNet() {
	m.net = nil
	delete(m.clearedFields, earthquake.FieldNet)
}

// SetCode sets the "code" field.
func (m *EarthquakeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *EarthquakeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *EarthquakeMutation) ClearCode() {
	m.code = nil
	m.clearedFields[earthquake.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *EarthquakeMutation) CodeCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *EarthquakeMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, earthquake.FieldCode)
}

// SetSources sets the "sources" field.
func (m *EarthquakeMutation) SetSources(s string) {
	m.sources = &s
}

// Sources returns the value of the "sources" field in the mutation.
func (m *EarthquakeMutation) Sources() (r string, exists bool) {
	v := m.sources
	if v == nil {
		return
	}
	return *v, true
}

// OldSources returns the old "sources" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldSources(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSources is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSources requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSources: %w", err)
	}
	return oldValue.Sources, nil
}

// ClearSources clears the value of the "sources" field.
func (m *EarthquakeMutation) ClearSources() {
	m.sources = nil
	m.clearedFields[earthquake.FieldSources] = struct{}{}
}

// SourcesCleared returns if the "sources" field was cleared in this mutation.
func (m *EarthquakeMutation) SourcesCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldSources]
	return ok
}

// ResetSources resets all changes to the "sources" field.
func (m *EarthquakeMutation) ResetSources() {
	m.sources = nil
	delete(m.clearedFields, earthquake.FieldSources)
}

// SetNst sets the "nst" field.
func (m *EarthquakeMutation) SetNst(i int) {
	m.nst = &i
	m.addnst = nil
}

// Nst returns the value of the "nst" field in the mutation.
func (m *EarthquakeMutation) Nst() (r int, exists bool) {
	v := m.nst
	if v == nil {
		return
	}
	return *v, true
}

// OldNst returns the old "nst" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldNst(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNst: %w", err)
	}
	return oldValue.Nst, nil
}

// AddNst adds i to the "nst" field.
func (m *EarthquakeMutation) AddNst(i int) {
	if m.addnst != nil {
		*m.addnst += i
	} else {
		m.addnst = &i
	}
}

// AddedNst returns the value that was added to the "nst" field in this mutation.
func (m *EarthquakeMutation) AddedNst() (r int, exists bool) {
	v := m.addnst
	if v == nil {
		return
	}
	return *v, true
}

// ClearNst clears the value of the "nst" field.
func (m *EarthquakeMutation) ClearNst() {
	m.nst = nil
	m.addnst = nil
	m.clearedFields[earthquake.FieldNst] = struct{}{}
}

// NstCleared returns if the "nst" field was cleared in this mutation.
func (m *EarthquakeMutation) NstCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldNst]
	return ok
}

// ResetNst resets all changes to the "nst" field.
func (m *EarthquakeMutation) ResetNst() {
	m.nst = nil
	m.addnst = nil
	delete(m.clearedFields, earthquake.FieldNst)
}

// SetDmin sets the "dmin" field.
func (m *EarthquakeMutation) SetDmin(f float64) {
	m.dmin = &f
	m.adddmin = nil
}

// Dmin returns the value of the "dmin" field in the mutation.
func (m *EarthquakeMutation) Dmin() (r float64, exists bool) {
	v := m.dmin
	if v == nil {
		return
	}
	return *v, true
}

// OldDmin returns the old "dmin" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldDmin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDmin: %w", err)
	}
	return oldValue.Dmin, nil
}

// AddDmin adds f to the "dmin" field.
func (m *EarthquakeMutation) AddDmin(f float64) {
	if m.adddmin != nil {
		*m.adddmin += f
	} else {
		m.adddmin = &f
	}
}

// AddedDmin returns the value that was added to the "dmin" field in this mutation.
func (m *EarthquakeMutation) AddedDmin() (r float64, exists bool) {
	v := m.adddmin
	if v == nil {
		return
	}
	return *v, true
}

// ClearDmin clears the value of the "dmin" field.
func (m *EarthquakeMutation) ClearDmin() {
	m.dmin = nil
	m.adddmin = nil
	m.clearedFields[earthquake.FieldDmin] = struct{}{}
}

// DminCleared returns if the "dmin" field was cleared in this mutation.
func (m *EarthquakeMutation) DminCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldDmin]
	return ok
}

// ResetDmin resets all changes to the "dmin" field.
func (m *EarthquakeMutation) ResetDmin() {
	m.dmin = nil
	m.adddmin = nil
	delete(m.clearedFields, earthquake.FieldDmin)
}

// SetRms sets the "rms" field.
func (m *EarthquakeMutation) SetRms(f float64) {
	m.rms = &f
	m.addrms = nil
}

// Rms returns the value of the "rms" field in the mutation.
func (m *EarthquakeMutation) Rms() (r float64, exists bool) {
	v := m.rms
	if v == nil {
		return
	}
	return *v, true
}

// OldRms returns the old "rms" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldRms(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRms: %w", err)
	}
	return oldValue.Rms, nil
}

// AddRms adds f to the "rms" field.
func (m *EarthquakeMutation) AddRms(f float64) {
	if m.addrms != nil {
		*m.addrms += f
	} else {
		m.addrms = &f
	}
}

// AddedRms returns the value that was added to the "rms" field in this mutation.
func (m *EarthquakeMutation) AddedRms() (r float64, exists bool) {
	v := m.addrms
	if v == nil {
		return
	}
	return *v, true
}

// ClearRms clears the value of the "rms" field.
func (m *EarthquakeMutation) ClearRms() {
	m.rms = nil
	m.addrms = nil
	m.clearedFields[earthquake.FieldRms] = struct{}{}
}

// RmsCleared returns if the "rms" field was cleared in this mutation.
func (m *EarthquakeMutation) RmsCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldRms]
	return ok
}

// ResetRms resets all changes to the "rms" field.
func (m *EarthquakeMutation) ResetRms() {
	m.rms = nil
	m.addrms = nil
	delete(m.clearedFields, earthquake.FieldRms)
}

// SetGap sets the "gap" field.
func (m *EarthquakeMutation) SetGap(f float64) {
	m.gap = &f
	m.addgap = nil
}

// Gap returns the value of the "gap" field in the mutation.
func (m *EarthquakeMutation) Gap() (r float64, exists bool) {
	v := m.gap
	if v == nil {
		return
	}
	return *v, true
}

// OldGap returns the old "gap" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldGap(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGap: %w", err)
	}
	return oldValue.Gap, nil
}

// AddGap adds f to the "gap" field.
func (m *EarthquakeMutation) AddGap(f float64) {
	if m.addgap != nil {
		*m.addgap += f
	} else {
		m.addgap = &f
	}
}

// AddedGap returns the value that was added to the "gap" field in this mutation.
func (m *EarthquakeMutation) AddedGap() (r float64, exists bool) {
	v := m.addgap
	if v == nil {
		return
	}
	return *v, true
}

// ClearGap clears the value of the "gap" field.
func (m *EarthquakeMutation) ClearGap() {
	m.gap = nil
	m.addgap = nil
	m.clearedFields[earthquake.FieldGap] = struct{}{}
}

// GapCleared returns if the "gap" field was cleared in this mutation.
func (m *EarthquakeMutation) GapCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldGap]
	return ok
}

// ResetGap resets all changes to the "gap" field.
func (m *EarthquakeMutation) ResetGap() {
	m.gap = nil
	m.addgap = nil
	delete(m.clearedFields, earthquake.FieldGap)
}

// SetCreatedAt sets the "created_at" field.
func (m *EarthquakeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EarthquakeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EarthquakeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[earthquake.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EarthquakeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EarthquakeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, earthquake.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EarthquakeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EarthquakeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EarthquakeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[earthquake.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EarthquakeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EarthquakeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, earthquake.FieldUpdatedAt)
}

// AddAssociatedEventIDs adds the "associated_events" edge to the AssociatedEvent entity by ids.
func (m *EarthquakeMutation) AddAssociatedEventIDs(ids ...int) {
	if m.associated_events == nil {
		m.associated_events = make(map[int]struct{})
	}
	for i := range ids {
		m.associated_events[ids[i]] = struct{}{}
	}
}

// ClearAssociatedEvents clears the "associated_events" edge to the AssociatedEvent entity.
func (m *EarthquakeMutation) ClearAssociatedEvents() {
	m.clearedassociated_events = true
}

// AssociatedEventsCleared reports if the "associated_events" edge to the AssociatedEvent entity was cleared.
func (m *EarthquakeMutation) AssociatedEventsCleared() bool {
	return m.clearedassociated_events
}

// RemoveAssociatedEventIDs removes the "associated_events" edge to the AssociatedEvent entity by IDs.
func (m *EarthquakeMutation) RemoveAssociatedEventIDs(ids ...int) {
	if m.removedassociated_events == nil {
		m.removedassociated_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.associated_events, ids[i])
		m.removedassociated_events[ids[i]] = struct{}{}
	}
}

// RemovedAssociatedEvents returns the removed IDs of the "associated_events" edge to the AssociatedEvent entity.
func (m *EarthquakeMutation) RemovedAssociatedEventsIDs() (ids []int) {
	for id := range m.removedassociated_events {
		ids = append(ids, id)
	}
	return
}

// AssociatedEventsIDs returns the "associated_events" edge IDs in the mutation.
func (m *EarthquakeMutation) AssociatedEventsIDs() (ids []int) {
	for id := range m.associated_events {
		ids = append(ids, id)
	}
	return
}

// ResetAssociatedEvents resets all changes to the "associated_events" edge.
func (m *EarthquakeMutation) ResetAssociatedEvents() {
	m.associated_events = nil
	m.clearedassociated_events = false
	m.removedassociated_events = nil
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *EarthquakeMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[earthquake.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *EarthquakeMutation) LocationCleared() bool {
	return m.LocationIDCleared() || m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *EarthquakeMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *EarthquakeMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// SetMagnitudeID sets the "magnitude" edge to the Magnitude entity by id.
func (m *EarthquakeMutation) SetMagnitudeID(id int) {
	m.magnitude = &id
}

// ClearMagnitude clears the "magnitude" edge to the Magnitude entity.
func (m *EarthquakeMutation) ClearMagnitude() {
	m.clearedmagnitude = true
	m.clearedFields[earthquake.FieldMagitudeID] = struct{}{}
}

// MagnitudeCleared reports if the "magnitude" edge to the Magnitude entity was cleared.
func (m *EarthquakeMutation) MagnitudeCleared() bool {
	return m.MagitudeIDCleared() || m.clearedmagnitude
}

// MagnitudeID returns the "magnitude" edge ID in the mutation.
func (m *EarthquakeMutation) MagnitudeID() (id int, exists bool) {
	if m.magnitude != nil {
		return *m.magnitude, true
	}
	return
}

// MagnitudeIDs returns the "magnitude" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MagnitudeID instead. It exists only for internal usage by the builders.
func (m *EarthquakeMutation) MagnitudeIDs() (ids []int) {
	if id := m.magnitude; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMagnitude resets all changes to the "magnitude" edge.
func (m *EarthquakeMutation) ResetMagnitude() {
	m.magnitude = nil
	m.clearedmagnitude = false
}

// ClearTime clears the "time" edge to the Time entity.
func (m *EarthquakeMutation) ClearTime() {
	m.clearedtime = true
	m.clearedFields[earthquake.FieldTimeID] = struct{}{}
}

// TimeCleared reports if the "time" edge to the Time entity was cleared.
func (m *EarthquakeMutation) TimeCleared() bool {
	return m.TimeIDCleared() || m.clearedtime
}

// TimeIDs returns the "time" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TimeID instead. It exists only for internal usage by the builders.
func (m *EarthquakeMutation) TimeIDs() (ids []int) {
	if id := m.time; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTime resets all changes to the "time" edge.
func (m *EarthquakeMutation) ResetTime() {
	m.time = nil
	m.clearedtime = false
}

// AddTypeIDs adds the "types" edge to the Type_eathquake entity by ids.
func (m *EarthquakeMutation) AddTypeIDs(ids ...int) {
	if m.types == nil {
		m.types = make(map[int]struct{})
	}
	for i := range ids {
		m.types[ids[i]] = struct{}{}
	}
}

// ClearTypes clears the "types" edge to the Type_eathquake entity.
func (m *EarthquakeMutation) ClearTypes() {
	m.clearedtypes = true
}

// TypesCleared reports if the "types" edge to the Type_eathquake entity was cleared.
func (m *EarthquakeMutation) TypesCleared() bool {
	return m.clearedtypes
}

// RemoveTypeIDs removes the "types" edge to the Type_eathquake entity by IDs.
func (m *EarthquakeMutation) RemoveTypeIDs(ids ...int) {
	if m.removedtypes == nil {
		m.removedtypes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.types, ids[i])
		m.removedtypes[ids[i]] = struct{}{}
	}
}

// RemovedTypes returns the removed IDs of the "types" edge to the Type_eathquake entity.
func (m *EarthquakeMutation) RemovedTypesIDs() (ids []int) {
	for id := range m.removedtypes {
		ids = append(ids, id)
	}
	return
}

// TypesIDs returns the "types" edge IDs in the mutation.
func (m *EarthquakeMutation) TypesIDs() (ids []int) {
	for id := range m.types {
		ids = append(ids, id)
	}
	return
}

// ResetTypes resets all changes to the "types" edge.
func (m *EarthquakeMutation) ResetTypes() {
	m.types = nil
	m.clearedtypes = false
	m.removedtypes = nil
}

// Where appends a list predicates to the EarthquakeMutation builder.
func (m *EarthquakeMutation) Where(ps ...predicate.Earthquake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EarthquakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EarthquakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Earthquake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EarthquakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EarthquakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Earthquake).
func (m *EarthquakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EarthquakeMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.location != nil {
		fields = append(fields, earthquake.FieldLocationID)
	}
	if m.time != nil {
		fields = append(fields, earthquake.FieldTimeID)
	}
	if m.magnitude != nil {
		fields = append(fields, earthquake.FieldMagitudeID)
	}
	if m.url != nil {
		fields = append(fields, earthquake.FieldURL)
	}
	if m.status != nil {
		fields = append(fields, earthquake.FieldStatus)
	}
	if m.tsunami != nil {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.net != nil {
		fields = append(fields, earthquake.FieldNet)
	}
	if m.code != nil {
		fields = append(fields, earthquake.FieldCode)
	}
	if m.sources != nil {
		fields = append(fields, earthquake.FieldSources)
	}
	if m.nst != nil {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.dmin != nil {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.rms != nil {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.gap != nil {
		fields = append(fields, earthquake.FieldGap)
	}
	if m.created_at != nil {
		fields = append(fields, earthquake.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, earthquake.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EarthquakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case earthquake.FieldLocationID:
		return m.LocationID()
	case earthquake.FieldTimeID:
		return m.TimeID()
	case earthquake.FieldMagitudeID:
		return m.MagitudeID()
	case earthquake.FieldURL:
		return m.URL()
	case earthquake.FieldStatus:
		return m.Status()
	case earthquake.FieldTsunami:
		return m.Tsunami()
	case earthquake.FieldNet:
		return m.Net()
	case earthquake.FieldCode:
		return m.Code()
	case earthquake.FieldSources:
		return m.Sources()
	case earthquake.FieldNst:
		return m.Nst()
	case earthquake.FieldDmin:
		return m.Dmin()
	case earthquake.FieldRms:
		return m.Rms()
	case earthquake.FieldGap:
		return m.Gap()
	case earthquake.FieldCreatedAt:
		return m.CreatedAt()
	case earthquake.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EarthquakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case earthquake.FieldLocationID:
		return m.OldLocationID(ctx)
	case earthquake.FieldTimeID:
		return m.OldTimeID(ctx)
	case earthquake.FieldMagitudeID:
		return m.OldMagitudeID(ctx)
	case earthquake.FieldURL:
		return m.OldURL(ctx)
	case earthquake.FieldStatus:
		return m.OldStatus(ctx)
	case earthquake.FieldTsunami:
		return m.OldTsunami(ctx)
	case earthquake.FieldNet:
		return m.OldNet(ctx)
	case earthquake.FieldCode:
		return m.OldCode(ctx)
	case earthquake.FieldSources:
		return m.OldSources(ctx)
	case earthquake.FieldNst:
		return m.OldNst(ctx)
	case earthquake.FieldDmin:
		return m.OldDmin(ctx)
	case earthquake.FieldRms:
		return m.OldRms(ctx)
	case earthquake.FieldGap:
		return m.OldGap(ctx)
	case earthquake.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case earthquake.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Earthquake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case earthquake.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case earthquake.FieldTimeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeID(v)
		return nil
	case earthquake.FieldMagitudeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagitudeID(v)
		return nil
	case earthquake.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case earthquake.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case earthquake.FieldTsunami:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTsunami(v)
		return nil
	case earthquake.FieldNet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNet(v)
		return nil
	case earthquake.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case earthquake.FieldSources:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSources(v)
		return nil
	case earthquake.FieldNst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNst(v)
		return nil
	case earthquake.FieldDmin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDmin(v)
		return nil
	case earthquake.FieldRms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRms(v)
		return nil
	case earthquake.FieldGap:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGap(v)
		return nil
	case earthquake.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case earthquake.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Earthquake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EarthquakeMutation) AddedFields() []string {
	var fields []string
	if m.addtsunami != nil {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.addnst != nil {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.adddmin != nil {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.addrms != nil {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.addgap != nil {
		fields = append(fields, earthquake.FieldGap)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EarthquakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case earthquake.FieldTsunami:
		return m.AddedTsunami()
	case earthquake.FieldNst:
		return m.AddedNst()
	case earthquake.FieldDmin:
		return m.AddedDmin()
	case earthquake.FieldRms:
		return m.AddedRms()
	case earthquake.FieldGap:
		return m.AddedGap()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case earthquake.FieldTsunami:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTsunami(v)
		return nil
	case earthquake.FieldNst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNst(v)
		return nil
	case earthquake.FieldDmin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDmin(v)
		return nil
	case earthquake.FieldRms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRms(v)
		return nil
	case earthquake.FieldGap:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGap(v)
		return nil
	}
	return fmt.Errorf("unknown Earthquake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EarthquakeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(earthquake.FieldLocationID) {
		fields = append(fields, earthquake.FieldLocationID)
	}
	if m.FieldCleared(earthquake.FieldTimeID) {
		fields = append(fields, earthquake.FieldTimeID)
	}
	if m.FieldCleared(earthquake.FieldMagitudeID) {
		fields = append(fields, earthquake.FieldMagitudeID)
	}
	if m.FieldCleared(earthquake.FieldURL) {
		fields = append(fields, earthquake.FieldURL)
	}
	if m.FieldCleared(earthquake.FieldStatus) {
		fields = append(fields, earthquake.FieldStatus)
	}
	if m.FieldCleared(earthquake.FieldTsunami) {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.FieldCleared(earthquake.FieldNet) {
		fields = append(fields, earthquake.FieldNet)
	}
	if m.FieldCleared(earthquake.FieldCode) {
		fields = append(fields, earthquake.FieldCode)
	}
	if m.FieldCleared(earthquake.FieldSources) {
		fields = append(fields, earthquake.FieldSources)
	}
	if m.FieldCleared(earthquake.FieldNst) {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.FieldCleared(earthquake.FieldDmin) {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.FieldCleared(earthquake.FieldRms) {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.FieldCleared(earthquake.FieldGap) {
		fields = append(fields, earthquake.FieldGap)
	}
	if m.FieldCleared(earthquake.FieldCreatedAt) {
		fields = append(fields, earthquake.FieldCreatedAt)
	}
	if m.FieldCleared(earthquake.FieldUpdatedAt) {
		fields = append(fields, earthquake.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EarthquakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EarthquakeMutation) ClearField(name string) error {
	switch name {
	case earthquake.FieldLocationID:
		m.ClearLocationID()
		return nil
	case earthquake.FieldTimeID:
		m.ClearTimeID()
		return nil
	case earthquake.FieldMagitudeID:
		m.ClearMagitudeID()
		return nil
	case earthquake.FieldURL:
		m.ClearURL()
		return nil
	case earthquake.FieldStatus:
		m.ClearStatus()
		return nil
	case earthquake.FieldTsunami:
		m.ClearTsunami()
		return nil
	case earthquake.FieldNet:
		m.ClearNet()
		return nil
	case earthquake.FieldCode:
		m.ClearCode()
		return nil
	case earthquake.FieldSources:
		m.ClearSources()
		return nil
	case earthquake.FieldNst:
		m.ClearNst()
		return nil
	case earthquake.FieldDmin:
		m.ClearDmin()
		return nil
	case earthquake.FieldRms:
		m.ClearRms()
		return nil
	case earthquake.FieldGap:
		m.ClearGap()
		return nil
	case earthquake.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case earthquake.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Earthquake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EarthquakeMutation) ResetField(name string) error {
	switch name {
	case earthquake.FieldLocationID:
		m.ResetLocationID()
		return nil
	case earthquake.FieldTimeID:
		m.ResetTimeID()
		return nil
	case earthquake.FieldMagitudeID:
		m.ResetMagitudeID()
		return nil
	case earthquake.FieldURL:
		m.ResetURL()
		return nil
	case earthquake.FieldStatus:
		m.ResetStatus()
		return nil
	case earthquake.FieldTsunami:
		m.ResetTsunami()
		return nil
	case earthquake.FieldNet:
		m.ResetNet()
		return nil
	case earthquake.FieldCode:
		m.ResetCode()
		return nil
	case earthquake.FieldSources:
		m.ResetSources()
		return nil
	case earthquake.FieldNst:
		m.ResetNst()
		return nil
	case earthquake.FieldDmin:
		m.ResetDmin()
		return nil
	case earthquake.FieldRms:
		m.ResetRms()
		return nil
	case earthquake.FieldGap:
		m.ResetGap()
		return nil
	case earthquake.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case earthquake.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Earthquake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EarthquakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.associated_events != nil {
		edges = append(edges, earthquake.EdgeAssociatedEvents)
	}
	if m.location != nil {
		edges = append(edges, earthquake.EdgeLocation)
	}
	if m.magnitude != nil {
		edges = append(edges, earthquake.EdgeMagnitude)
	}
	if m.time != nil {
		edges = append(edges, earthquake.EdgeTime)
	}
	if m.types != nil {
		edges = append(edges, earthquake.EdgeTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EarthquakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case earthquake.EdgeAssociatedEvents:
		ids := make([]ent.Value, 0, len(m.associated_events))
		for id := range m.associated_events {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case earthquake.EdgeMagnitude:
		if id := m.magnitude; id != nil {
			return []ent.Value{*id}
		}
	case earthquake.EdgeTime:
		if id := m.time; id != nil {
			return []ent.Value{*id}
		}
	case earthquake.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.types))
		for id := range m.types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EarthquakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedassociated_events != nil {
		edges = append(edges, earthquake.EdgeAssociatedEvents)
	}
	if m.removedtypes != nil {
		edges = append(edges, earthquake.EdgeTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EarthquakeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case earthquake.EdgeAssociatedEvents:
		ids := make([]ent.Value, 0, len(m.removedassociated_events))
		for id := range m.removedassociated_events {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeTypes:
		ids := make([]ent.Value, 0, len(m.removedtypes))
		for id := range m.removedtypes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EarthquakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedassociated_events {
		edges = append(edges, earthquake.EdgeAssociatedEvents)
	}
	if m.clearedlocation {
		edges = append(edges, earthquake.EdgeLocation)
	}
	if m.clearedmagnitude {
		edges = append(edges, earthquake.EdgeMagnitude)
	}
	if m.clearedtime {
		edges = append(edges, earthquake.EdgeTime)
	}
	if m.clearedtypes {
		edges = append(edges, earthquake.EdgeTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EarthquakeMutation) EdgeCleared(name string) bool {
	switch name {
	case earthquake.EdgeAssociatedEvents:
		return m.clearedassociated_events
	case earthquake.EdgeLocation:
		return m.clearedlocation
	case earthquake.EdgeMagnitude:
		return m.clearedmagnitude
	case earthquake.EdgeTime:
		return m.clearedtime
	case earthquake.EdgeTypes:
		return m.clearedtypes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EarthquakeMutation) ClearEdge(name string) error {
	switch name {
	case earthquake.EdgeLocation:
		m.ClearLocation()
		return nil
	case earthquake.EdgeMagnitude:
		m.ClearMagnitude()
		return nil
	case earthquake.EdgeTime:
		m.ClearTime()
		return nil
	}
	return fmt.Errorf("unknown Earthquake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EarthquakeMutation) ResetEdge(name string) error {
	switch name {
	case earthquake.EdgeAssociatedEvents:
		m.ResetAssociatedEvents()
		return nil
	case earthquake.EdgeLocation:
		m.ResetLocation()
		return nil
	case earthquake.EdgeMagnitude:
		m.ResetMagnitude()
		return nil
	case earthquake.EdgeTime:
		m.ResetTime()
		return nil
	case earthquake.EdgeTypes:
		m.ResetTypes()
		return nil
	}
	return fmt.Errorf("unknown Earthquake edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	longitude          *float64
	addlongitude       *float64
	latitude           *float64
	addlatitude        *float64
	dept               *float64
	adddept            *float64
	place              *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	earthquakes        map[int]struct{}
	removedearthquakes map[int]struct{}
	clearedearthquakes bool
	done               bool
	oldValue           func(context.Context) (*Location, error)
	predicates         []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLongitude sets the "longitude" field.
func (m *LocationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *LocationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *LocationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *LocationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *LocationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetLatitude sets the "latitude" field.
func (m *LocationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *LocationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *LocationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *LocationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *LocationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetDept sets the "dept" field.
func (m *LocationMutation) SetDept(f float64) {
	m.dept = &f
	m.adddept = nil
}

// Dept returns the value of the "dept" field in the mutation.
func (m *LocationMutation) Dept() (r float64, exists bool) {
	v := m.dept
	if v == nil {
		return
	}
	return *v, true
}

// OldDept returns the old "dept" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDept(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDept is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDept requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDept: %w", err)
	}
	return oldValue.Dept, nil
}

// AddDept adds f to the "dept" field.
func (m *LocationMutation) AddDept(f float64) {
	if m.adddept != nil {
		*m.adddept += f
	} else {
		m.adddept = &f
	}
}

// AddedDept returns the value that was added to the "dept" field in this mutation.
func (m *LocationMutation) AddedDept() (r float64, exists bool) {
	v := m.adddept
	if v == nil {
		return
	}
	return *v, true
}

// ResetDept resets all changes to the "dept" field.
func (m *LocationMutation) ResetDept() {
	m.dept = nil
	m.adddept = nil
}

// SetPlace sets the "place" field.
func (m *LocationMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *LocationMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ClearPlace clears the value of the "place" field.
func (m *LocationMutation) ClearPlace() {
	m.place = nil
	m.clearedFields[location.FieldPlace] = struct{}{}
}

// PlaceCleared returns if the "place" field was cleared in this mutation.
func (m *LocationMutation) PlaceCleared() bool {
	_, ok := m.clearedFields[location.FieldPlace]
	return ok
}

// ResetPlace resets all changes to the "place" field.
func (m *LocationMutation) ResetPlace() {
	m.place = nil
	delete(m.clearedFields, location.FieldPlace)
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *LocationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[location.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *LocationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[location.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, location.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *LocationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[location.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *LocationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[location.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, location.FieldUpdatedAt)
}

// AddEarthquakeIDs adds the "earthquakes" edge to the Earthquake entity by ids.
func (m *LocationMutation) AddEarthquakeIDs(ids ...int) {
	if m.earthquakes == nil {
		m.earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.earthquakes[ids[i]] = struct{}{}
	}
}

// ClearEarthquakes clears the "earthquakes" edge to the Earthquake entity.
func (m *LocationMutation) ClearEarthquakes() {
	m.clearedearthquakes = true
}

// EarthquakesCleared reports if the "earthquakes" edge to the Earthquake entity was cleared.
func (m *LocationMutation) EarthquakesCleared() bool {
	return m.clearedearthquakes
}

// RemoveEarthquakeIDs removes the "earthquakes" edge to the Earthquake entity by IDs.
func (m *LocationMutation) RemoveEarthquakeIDs(ids ...int) {
	if m.removedearthquakes == nil {
		m.removedearthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.earthquakes, ids[i])
		m.removedearthquakes[ids[i]] = struct{}{}
	}
}

// RemovedEarthquakes returns the removed IDs of the "earthquakes" edge to the Earthquake entity.
func (m *LocationMutation) RemovedEarthquakesIDs() (ids []int) {
	for id := range m.removedearthquakes {
		ids = append(ids, id)
	}
	return
}

// EarthquakesIDs returns the "earthquakes" edge IDs in the mutation.
func (m *LocationMutation) EarthquakesIDs() (ids []int) {
	for id := range m.earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetEarthquakes resets all changes to the "earthquakes" edge.
func (m *LocationMutation) ResetEarthquakes() {
	m.earthquakes = nil
	m.clearedearthquakes = false
	m.removedearthquakes = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.longitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.dept != nil {
		fields = append(fields, location.FieldDept)
	}
	if m.place != nil {
		fields = append(fields, location.FieldPlace)
	}
	if m.created_at != nil {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, location.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldLongitude:
		return m.Longitude()
	case location.FieldLatitude:
		return m.Latitude()
	case location.FieldDept:
		return m.Dept()
	case location.FieldPlace:
		return m.Place()
	case location.FieldCreatedAt:
		return m.CreatedAt()
	case location.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldLongitude:
		return m.OldLongitude(ctx)
	case location.FieldLatitude:
		return m.OldLatitude(ctx)
	case location.FieldDept:
		return m.OldDept(ctx)
	case location.FieldPlace:
		return m.OldPlace(ctx)
	case location.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case location.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case location.FieldDept:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDept(v)
		return nil
	case location.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case location.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case location.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	var fields []string
	if m.addlongitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.addlatitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.adddept != nil {
		fields = append(fields, location.FieldDept)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case location.FieldLongitude:
		return m.AddedLongitude()
	case location.FieldLatitude:
		return m.AddedLatitude()
	case location.FieldDept:
		return m.AddedDept()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case location.FieldDept:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDept(v)
		return nil
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldPlace) {
		fields = append(fields, location.FieldPlace)
	}
	if m.FieldCleared(location.FieldCreatedAt) {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.FieldCleared(location.FieldUpdatedAt) {
		fields = append(fields, location.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldPlace:
		m.ClearPlace()
		return nil
	case location.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case location.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldLongitude:
		m.ResetLongitude()
		return nil
	case location.FieldLatitude:
		m.ResetLatitude()
		return nil
	case location.FieldDept:
		m.ResetDept()
		return nil
	case location.FieldPlace:
		m.ResetPlace()
		return nil
	case location.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case location.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquakes != nil {
		edges = append(edges, location.EdgeEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.earthquakes))
		for id := range m.earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedearthquakes != nil {
		edges = append(edges, location.EdgeEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedearthquakes))
		for id := range m.removedearthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquakes {
		edges = append(edges, location.EdgeEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeEarthquakes:
		return m.clearedearthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeEarthquakes:
		m.ResetEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// MagnitudeMutation represents an operation that mutates the Magnitude nodes in the graph.
type MagnitudeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	magnitude_value    *float64
	addmagnitude_value *float64
	magnitude_type     *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	earthquakes        map[int]struct{}
	removedearthquakes map[int]struct{}
	clearedearthquakes bool
	done               bool
	oldValue           func(context.Context) (*Magnitude, error)
	predicates         []predicate.Magnitude
}

var _ ent.Mutation = (*MagnitudeMutation)(nil)

// magnitudeOption allows management of the mutation configuration using functional options.
type magnitudeOption func(*MagnitudeMutation)

// newMagnitudeMutation creates new mutation for the Magnitude entity.
func newMagnitudeMutation(c config, op Op, opts ...magnitudeOption) *MagnitudeMutation {
	m := &MagnitudeMutation{
		config:        c,
		op:            op,
		typ:           TypeMagnitude,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMagnitudeID sets the ID field of the mutation.
func withMagnitudeID(id int) magnitudeOption {
	return func(m *MagnitudeMutation) {
		var (
			err   error
			once  sync.Once
			value *Magnitude
		)
		m.oldValue = func(ctx context.Context) (*Magnitude, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Magnitude.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMagnitude sets the old Magnitude of the mutation.
func withMagnitude(node *Magnitude) magnitudeOption {
	return func(m *MagnitudeMutation) {
		m.oldValue = func(context.Context) (*Magnitude, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MagnitudeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MagnitudeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Magnitude entities.
func (m *MagnitudeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MagnitudeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MagnitudeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Magnitude.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMagnitudeValue sets the "magnitude_value" field.
func (m *MagnitudeMutation) SetMagnitudeValue(f float64) {
	m.magnitude_value = &f
	m.addmagnitude_value = nil
}

// MagnitudeValue returns the value of the "magnitude_value" field in the mutation.
func (m *MagnitudeMutation) MagnitudeValue() (r float64, exists bool) {
	v := m.magnitude_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMagnitudeValue returns the old "magnitude_value" field's value of the Magnitude entity.
// If the Magnitude object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagnitudeMutation) OldMagnitudeValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagnitudeValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagnitudeValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagnitudeValue: %w", err)
	}
	return oldValue.MagnitudeValue, nil
}

// AddMagnitudeValue adds f to the "magnitude_value" field.
func (m *MagnitudeMutation) AddMagnitudeValue(f float64) {
	if m.addmagnitude_value != nil {
		*m.addmagnitude_value += f
	} else {
		m.addmagnitude_value = &f
	}
}

// AddedMagnitudeValue returns the value that was added to the "magnitude_value" field in this mutation.
func (m *MagnitudeMutation) AddedMagnitudeValue() (r float64, exists bool) {
	v := m.addmagnitude_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearMagnitudeValue clears the value of the "magnitude_value" field.
func (m *MagnitudeMutation) ClearMagnitudeValue() {
	m.magnitude_value = nil
	m.addmagnitude_value = nil
	m.clearedFields[magnitude.FieldMagnitudeValue] = struct{}{}
}

// MagnitudeValueCleared returns if the "magnitude_value" field was cleared in this mutation.
func (m *MagnitudeMutation) MagnitudeValueCleared() bool {
	_, ok := m.clearedFields[magnitude.FieldMagnitudeValue]
	return ok
}

// ResetMagnitudeValue resets all changes to the "magnitude_value" field.
func (m *MagnitudeMutation) ResetMagnitudeValue() {
	m.magnitude_value = nil
	m.addmagnitude_value = nil
	delete(m.clearedFields, magnitude.FieldMagnitudeValue)
}

// SetMagnitudeType sets the "magnitude_type" field.
func (m *MagnitudeMutation) SetMagnitudeType(s string) {
	m.magnitude_type = &s
}

// MagnitudeType returns the value of the "magnitude_type" field in the mutation.
func (m *MagnitudeMutation) MagnitudeType() (r string, exists bool) {
	v := m.magnitude_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMagnitudeType returns the old "magnitude_type" field's value of the Magnitude entity.
// If the Magnitude object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagnitudeMutation) OldMagnitudeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagnitudeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagnitudeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagnitudeType: %w", err)
	}
	return oldValue.MagnitudeType, nil
}

// ClearMagnitudeType clears the value of the "magnitude_type" field.
func (m *MagnitudeMutation) ClearMagnitudeType() {
	m.magnitude_type = nil
	m.clearedFields[magnitude.FieldMagnitudeType] = struct{}{}
}

// MagnitudeTypeCleared returns if the "magnitude_type" field was cleared in this mutation.
func (m *MagnitudeMutation) MagnitudeTypeCleared() bool {
	_, ok := m.clearedFields[magnitude.FieldMagnitudeType]
	return ok
}

// ResetMagnitudeType resets all changes to the "magnitude_type" field.
func (m *MagnitudeMutation) ResetMagnitudeType() {
	m.magnitude_type = nil
	delete(m.clearedFields, magnitude.FieldMagnitudeType)
}

// SetCreatedAt sets the "created_at" field.
func (m *MagnitudeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MagnitudeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Magnitude entity.
// If the Magnitude object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagnitudeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MagnitudeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[magnitude.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MagnitudeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[magnitude.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MagnitudeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, magnitude.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MagnitudeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MagnitudeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Magnitude entity.
// If the Magnitude object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MagnitudeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MagnitudeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[magnitude.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MagnitudeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[magnitude.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MagnitudeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, magnitude.FieldUpdatedAt)
}

// AddEarthquakeIDs adds the "earthquakes" edge to the Earthquake entity by ids.
func (m *MagnitudeMutation) AddEarthquakeIDs(ids ...int) {
	if m.earthquakes == nil {
		m.earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.earthquakes[ids[i]] = struct{}{}
	}
}

// ClearEarthquakes clears the "earthquakes" edge to the Earthquake entity.
func (m *MagnitudeMutation) ClearEarthquakes() {
	m.clearedearthquakes = true
}

// EarthquakesCleared reports if the "earthquakes" edge to the Earthquake entity was cleared.
func (m *MagnitudeMutation) EarthquakesCleared() bool {
	return m.clearedearthquakes
}

// RemoveEarthquakeIDs removes the "earthquakes" edge to the Earthquake entity by IDs.
func (m *MagnitudeMutation) RemoveEarthquakeIDs(ids ...int) {
	if m.removedearthquakes == nil {
		m.removedearthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.earthquakes, ids[i])
		m.removedearthquakes[ids[i]] = struct{}{}
	}
}

// RemovedEarthquakes returns the removed IDs of the "earthquakes" edge to the Earthquake entity.
func (m *MagnitudeMutation) RemovedEarthquakesIDs() (ids []int) {
	for id := range m.removedearthquakes {
		ids = append(ids, id)
	}
	return
}

// EarthquakesIDs returns the "earthquakes" edge IDs in the mutation.
func (m *MagnitudeMutation) EarthquakesIDs() (ids []int) {
	for id := range m.earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetEarthquakes resets all changes to the "earthquakes" edge.
func (m *MagnitudeMutation) ResetEarthquakes() {
	m.earthquakes = nil
	m.clearedearthquakes = false
	m.removedearthquakes = nil
}

// Where appends a list predicates to the MagnitudeMutation builder.
func (m *MagnitudeMutation) Where(ps ...predicate.Magnitude) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MagnitudeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MagnitudeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Magnitude, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MagnitudeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MagnitudeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Magnitude).
func (m *MagnitudeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MagnitudeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.magnitude_value != nil {
		fields = append(fields, magnitude.FieldMagnitudeValue)
	}
	if m.magnitude_type != nil {
		fields = append(fields, magnitude.FieldMagnitudeType)
	}
	if m.created_at != nil {
		fields = append(fields, magnitude.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, magnitude.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MagnitudeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case magnitude.FieldMagnitudeValue:
		return m.MagnitudeValue()
	case magnitude.FieldMagnitudeType:
		return m.MagnitudeType()
	case magnitude.FieldCreatedAt:
		return m.CreatedAt()
	case magnitude.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MagnitudeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case magnitude.FieldMagnitudeValue:
		return m.OldMagnitudeValue(ctx)
	case magnitude.FieldMagnitudeType:
		return m.OldMagnitudeType(ctx)
	case magnitude.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case magnitude.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Magnitude field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagnitudeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case magnitude.FieldMagnitudeValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagnitudeValue(v)
		return nil
	case magnitude.FieldMagnitudeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagnitudeType(v)
		return nil
	case magnitude.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case magnitude.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Magnitude field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MagnitudeMutation) AddedFields() []string {
	var fields []string
	if m.addmagnitude_value != nil {
		fields = append(fields, magnitude.FieldMagnitudeValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MagnitudeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case magnitude.FieldMagnitudeValue:
		return m.AddedMagnitudeValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MagnitudeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case magnitude.FieldMagnitudeValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMagnitudeValue(v)
		return nil
	}
	return fmt.Errorf("unknown Magnitude numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MagnitudeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(magnitude.FieldMagnitudeValue) {
		fields = append(fields, magnitude.FieldMagnitudeValue)
	}
	if m.FieldCleared(magnitude.FieldMagnitudeType) {
		fields = append(fields, magnitude.FieldMagnitudeType)
	}
	if m.FieldCleared(magnitude.FieldCreatedAt) {
		fields = append(fields, magnitude.FieldCreatedAt)
	}
	if m.FieldCleared(magnitude.FieldUpdatedAt) {
		fields = append(fields, magnitude.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MagnitudeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MagnitudeMutation) ClearField(name string) error {
	switch name {
	case magnitude.FieldMagnitudeValue:
		m.ClearMagnitudeValue()
		return nil
	case magnitude.FieldMagnitudeType:
		m.ClearMagnitudeType()
		return nil
	case magnitude.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case magnitude.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Magnitude nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MagnitudeMutation) ResetField(name string) error {
	switch name {
	case magnitude.FieldMagnitudeValue:
		m.ResetMagnitudeValue()
		return nil
	case magnitude.FieldMagnitudeType:
		m.ResetMagnitudeType()
		return nil
	case magnitude.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case magnitude.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Magnitude field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MagnitudeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquakes != nil {
		edges = append(edges, magnitude.EdgeEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MagnitudeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case magnitude.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.earthquakes))
		for id := range m.earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MagnitudeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedearthquakes != nil {
		edges = append(edges, magnitude.EdgeEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MagnitudeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case magnitude.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedearthquakes))
		for id := range m.removedearthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MagnitudeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquakes {
		edges = append(edges, magnitude.EdgeEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MagnitudeMutation) EdgeCleared(name string) bool {
	switch name {
	case magnitude.EdgeEarthquakes:
		return m.clearedearthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MagnitudeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Magnitude unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MagnitudeMutation) ResetEdge(name string) error {
	switch name {
	case magnitude.EdgeEarthquakes:
		m.ResetEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown Magnitude edge %s", name)
}

// RequestMutation represents an operation that mutates the Request nodes in the graph.
type RequestMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	request_url             *string
	request_method          *string
	request_headers         *map[string]interface{}
	request_body            *map[string]interface{}
	response_status_code    *int32
	addresponse_status_code *int32
	response_body           *map[string]interface{}
	request_timestamp       *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*Request, error)
	predicates              []predicate.Request
}

var _ ent.Mutation = (*RequestMutation)(nil)

// requestOption allows management of the mutation configuration using functional options.
type requestOption func(*RequestMutation)

// newRequestMutation creates new mutation for the Request entity.
func newRequestMutation(c config, op Op, opts ...requestOption) *RequestMutation {
	m := &RequestMutation{
		config:        c,
		op:            op,
		typ:           TypeRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestID sets the ID field of the mutation.
func withRequestID(id int) requestOption {
	return func(m *RequestMutation) {
		var (
			err   error
			once  sync.Once
			value *Request
		)
		m.oldValue = func(ctx context.Context) (*Request, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Request.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequest sets the old Request of the mutation.
func withRequest(node *Request) requestOption {
	return func(m *RequestMutation) {
		m.oldValue = func(context.Context) (*Request, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Request entities.
func (m *RequestMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Request.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestURL sets the "request_url" field.
func (m *RequestMutation) SetRequestURL(s string) {
	m.request_url = &s
}

// RequestURL returns the value of the "request_url" field in the mutation.
func (m *RequestMutation) RequestURL() (r string, exists bool) {
	v := m.request_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestURL returns the old "request_url" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestURL: %w", err)
	}
	return oldValue.RequestURL, nil
}

// ClearRequestURL clears the value of the "request_url" field.
func (m *RequestMutation) ClearRequestURL() {
	m.request_url = nil
	m.clearedFields[request.FieldRequestURL] = struct{}{}
}

// RequestURLCleared returns if the "request_url" field was cleared in this mutation.
func (m *RequestMutation) RequestURLCleared() bool {
	_, ok := m.clearedFields[request.FieldRequestURL]
	return ok
}

// ResetRequestURL resets all changes to the "request_url" field.
func (m *RequestMutation) ResetRequestURL() {
	m.request_url = nil
	delete(m.clearedFields, request.FieldRequestURL)
}

// SetRequestMethod sets the "request_method" field.
func (m *RequestMutation) SetRequestMethod(s string) {
	m.request_method = &s
}

// RequestMethod returns the value of the "request_method" field in the mutation.
func (m *RequestMutation) RequestMethod() (r string, exists bool) {
	v := m.request_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestMethod returns the old "request_method" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestMethod: %w", err)
	}
	return oldValue.RequestMethod, nil
}

// ClearRequestMethod clears the value of the "request_method" field.
func (m *RequestMutation) ClearRequestMethod() {
	m.request_method = nil
	m.clearedFields[request.FieldRequestMethod] = struct{}{}
}

// RequestMethodCleared returns if the "request_method" field was cleared in this mutation.
func (m *RequestMutation) RequestMethodCleared() bool {
	_, ok := m.clearedFields[request.FieldRequestMethod]
	return ok
}

// ResetRequestMethod resets all changes to the "request_method" field.
func (m *RequestMutation) ResetRequestMethod() {
	m.request_method = nil
	delete(m.clearedFields, request.FieldRequestMethod)
}

// SetRequestHeaders sets the "request_headers" field.
func (m *RequestMutation) SetRequestHeaders(value map[string]interface{}) {
	m.request_headers = &value
}

// RequestHeaders returns the value of the "request_headers" field in the mutation.
func (m *RequestMutation) RequestHeaders() (r map[string]interface{}, exists bool) {
	v := m.request_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestHeaders returns the old "request_headers" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestHeaders(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestHeaders: %w", err)
	}
	return oldValue.RequestHeaders, nil
}

// ClearRequestHeaders clears the value of the "request_headers" field.
func (m *RequestMutation) ClearRequestHeaders() {
	m.request_headers = nil
	m.clearedFields[request.FieldRequestHeaders] = struct{}{}
}

// RequestHeadersCleared returns if the "request_headers" field was cleared in this mutation.
func (m *RequestMutation) RequestHeadersCleared() bool {
	_, ok := m.clearedFields[request.FieldRequestHeaders]
	return ok
}

// ResetRequestHeaders resets all changes to the "request_headers" field.
func (m *RequestMutation) ResetRequestHeaders() {
	m.request_headers = nil
	delete(m.clearedFields, request.FieldRequestHeaders)
}

// SetRequestBody sets the "request_body" field.
func (m *RequestMutation) SetRequestBody(value map[string]interface{}) {
	m.request_body = &value
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *RequestMutation) RequestBody() (r map[string]interface{}, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestBody(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *RequestMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[request.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *RequestMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[request.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *RequestMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, request.FieldRequestBody)
}

// SetResponseStatusCode sets the "response_status_code" field.
func (m *RequestMutation) SetResponseStatusCode(i int32) {
	m.response_status_code = &i
	m.addresponse_status_code = nil
}

// ResponseStatusCode returns the value of the "response_status_code" field in the mutation.
func (m *RequestMutation) ResponseStatusCode() (r int32, exists bool) {
	v := m.response_status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseStatusCode returns the old "response_status_code" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseStatusCode(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseStatusCode: %w", err)
	}
	return oldValue.ResponseStatusCode, nil
}

// AddResponseStatusCode adds i to the "response_status_code" field.
func (m *RequestMutation) AddResponseStatusCode(i int32) {
	if m.addresponse_status_code != nil {
		*m.addresponse_status_code += i
	} else {
		m.addresponse_status_code = &i
	}
}

// AddedResponseStatusCode returns the value that was added to the "response_status_code" field in this mutation.
func (m *RequestMutation) AddedResponseStatusCode() (r int32, exists bool) {
	v := m.addresponse_status_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearResponseStatusCode clears the value of the "response_status_code" field.
func (m *RequestMutation) ClearResponseStatusCode() {
	m.response_status_code = nil
	m.addresponse_status_code = nil
	m.clearedFields[request.FieldResponseStatusCode] = struct{}{}
}

// ResponseStatusCodeCleared returns if the "response_status_code" field was cleared in this mutation.
func (m *RequestMutation) ResponseStatusCodeCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseStatusCode]
	return ok
}

// ResetResponseStatusCode resets all changes to the "response_status_code" field.
func (m *RequestMutation) ResetResponseStatusCode() {
	m.response_status_code = nil
	m.addresponse_status_code = nil
	delete(m.clearedFields, request.FieldResponseStatusCode)
}

// SetResponseBody sets the "response_body" field.
func (m *RequestMutation) SetResponseBody(value map[string]interface{}) {
	m.response_body = &value
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *RequestMutation) ResponseBody() (r map[string]interface{}, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseBody(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *RequestMutation) ClearResponseBody() {
	m.response_body = nil
	m.clearedFields[request.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *RequestMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *RequestMutation) ResetResponseBody() {
	m.response_body = nil
	delete(m.clearedFields, request.FieldResponseBody)
}

// SetRequestTimestamp sets the "request_timestamp" field.
func (m *RequestMutation) SetRequestTimestamp(t time.Time) {
	m.request_timestamp = &t
}

// RequestTimestamp returns the value of the "request_timestamp" field in the mutation.
func (m *RequestMutation) RequestTimestamp() (r time.Time, exists bool) {
	v := m.request_timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestTimestamp returns the old "request_timestamp" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestTimestamp: %w", err)
	}
	return oldValue.RequestTimestamp, nil
}

// ClearRequestTimestamp clears the value of the "request_timestamp" field.
func (m *RequestMutation) ClearRequestTimestamp() {
	m.request_timestamp = nil
	m.clearedFields[request.FieldRequestTimestamp] = struct{}{}
}

// RequestTimestampCleared returns if the "request_timestamp" field was cleared in this mutation.
func (m *RequestMutation) RequestTimestampCleared() bool {
	_, ok := m.clearedFields[request.FieldRequestTimestamp]
	return ok
}

// ResetRequestTimestamp resets all changes to the "request_timestamp" field.
func (m *RequestMutation) ResetRequestTimestamp() {
	m.request_timestamp = nil
	delete(m.clearedFields, request.FieldRequestTimestamp)
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RequestMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[request.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RequestMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[request.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, request.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RequestMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[request.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RequestMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[request.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, request.FieldUpdatedAt)
}

// Where appends a list predicates to the RequestMutation builder.
func (m *RequestMutation) Where(ps ...predicate.Request) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Request, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Request).
func (m *RequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.request_url != nil {
		fields = append(fields, request.FieldRequestURL)
	}
	if m.request_method != nil {
		fields = append(fields, request.FieldRequestMethod)
	}
	if m.request_headers != nil {
		fields = append(fields, request.FieldRequestHeaders)
	}
	if m.request_body != nil {
		fields = append(fields, request.FieldRequestBody)
	}
	if m.response_status_code != nil {
		fields = append(fields, request.FieldResponseStatusCode)
	}
	if m.response_body != nil {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.request_timestamp != nil {
		fields = append(fields, request.FieldRequestTimestamp)
	}
	if m.created_at != nil {
		fields = append(fields, request.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, request.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case request.FieldRequestURL:
		return m.RequestURL()
	case request.FieldRequestMethod:
		return m.RequestMethod()
	case request.FieldRequestHeaders:
		return m.RequestHeaders()
	case request.FieldRequestBody:
		return m.RequestBody()
	case request.FieldResponseStatusCode:
		return m.ResponseStatusCode()
	case request.FieldResponseBody:
		return m.ResponseBody()
	case request.FieldRequestTimestamp:
		return m.RequestTimestamp()
	case request.FieldCreatedAt:
		return m.CreatedAt()
	case request.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case request.FieldRequestURL:
		return m.OldRequestURL(ctx)
	case request.FieldRequestMethod:
		return m.OldRequestMethod(ctx)
	case request.FieldRequestHeaders:
		return m.OldRequestHeaders(ctx)
	case request.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case request.FieldResponseStatusCode:
		return m.OldResponseStatusCode(ctx)
	case request.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case request.FieldRequestTimestamp:
		return m.OldRequestTimestamp(ctx)
	case request.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case request.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Request field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case request.FieldRequestURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestURL(v)
		return nil
	case request.FieldRequestMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestMethod(v)
		return nil
	case request.FieldRequestHeaders:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestHeaders(v)
		return nil
	case request.FieldRequestBody:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case request.FieldResponseStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseStatusCode(v)
		return nil
	case request.FieldResponseBody:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case request.FieldRequestTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestTimestamp(v)
		return nil
	case request.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case request.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestMutation) AddedFields() []string {
	var fields []string
	if m.addresponse_status_code != nil {
		fields = append(fields, request.FieldResponseStatusCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case request.FieldResponseStatusCode:
		return m.AddedResponseStatusCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case request.FieldResponseStatusCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseStatusCode(v)
		return nil
	}
	return fmt.Errorf("unknown Request numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(request.FieldRequestURL) {
		fields = append(fields, request.FieldRequestURL)
	}
	if m.FieldCleared(request.FieldRequestMethod) {
		fields = append(fields, request.FieldRequestMethod)
	}
	if m.FieldCleared(request.FieldRequestHeaders) {
		fields = append(fields, request.FieldRequestHeaders)
	}
	if m.FieldCleared(request.FieldRequestBody) {
		fields = append(fields, request.FieldRequestBody)
	}
	if m.FieldCleared(request.FieldResponseStatusCode) {
		fields = append(fields, request.FieldResponseStatusCode)
	}
	if m.FieldCleared(request.FieldResponseBody) {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.FieldCleared(request.FieldRequestTimestamp) {
		fields = append(fields, request.FieldRequestTimestamp)
	}
	if m.FieldCleared(request.FieldCreatedAt) {
		fields = append(fields, request.FieldCreatedAt)
	}
	if m.FieldCleared(request.FieldUpdatedAt) {
		fields = append(fields, request.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestMutation) ClearField(name string) error {
	switch name {
	case request.FieldRequestURL:
		m.ClearRequestURL()
		return nil
	case request.FieldRequestMethod:
		m.ClearRequestMethod()
		return nil
	case request.FieldRequestHeaders:
		m.ClearRequestHeaders()
		return nil
	case request.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	case request.FieldResponseStatusCode:
		m.ClearResponseStatusCode()
		return nil
	case request.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case request.FieldRequestTimestamp:
		m.ClearRequestTimestamp()
		return nil
	case request.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case request.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Request nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestMutation) ResetField(name string) error {
	switch name {
	case request.FieldRequestURL:
		m.ResetRequestURL()
		return nil
	case request.FieldRequestMethod:
		m.ResetRequestMethod()
		return nil
	case request.FieldRequestHeaders:
		m.ResetRequestHeaders()
		return nil
	case request.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case request.FieldResponseStatusCode:
		m.ResetResponseStatusCode()
		return nil
	case request.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case request.FieldRequestTimestamp:
		m.ResetRequestTimestamp()
		return nil
	case request.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case request.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Request unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Request edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	role_name     *string
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleName sets the "role_name" field.
func (m *RoleMutation) SetRoleName(s string) {
	m.role_name = &s
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *RoleMutation) RoleName() (r string, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ClearRoleName clears the value of the "role_name" field.
func (m *RoleMutation) ClearRoleName() {
	m.role_name = nil
	m.clearedFields[role.FieldRoleName] = struct{}{}
}

// RoleNameCleared returns if the "role_name" field was cleared in this mutation.
func (m *RoleMutation) RoleNameCleared() bool {
	_, ok := m.clearedFields[role.FieldRoleName]
	return ok
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *RoleMutation) ResetRoleName() {
	m.role_name = nil
	delete(m.clearedFields, role.FieldRoleName)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role_name != nil {
		fields = append(fields, role.FieldRoleName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldRoleName:
		return m.RoleName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldRoleName:
		return m.OldRoleName(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldRoleName) {
		fields = append(fields, role.FieldRoleName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldRoleName:
		m.ClearRoleName()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldRoleName:
		m.ResetRoleName()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SchemaMigrationMutation represents an operation that mutates the SchemaMigration nodes in the graph.
type SchemaMigrationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	dirty         *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SchemaMigration, error)
	predicates    []predicate.SchemaMigration
}

var _ ent.Mutation = (*SchemaMigrationMutation)(nil)

// schemamigrationOption allows management of the mutation configuration using functional options.
type schemamigrationOption func(*SchemaMigrationMutation)

// newSchemaMigrationMutation creates new mutation for the SchemaMigration entity.
func newSchemaMigrationMutation(c config, op Op, opts ...schemamigrationOption) *SchemaMigrationMutation {
	m := &SchemaMigrationMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemaMigration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemaMigrationID sets the ID field of the mutation.
func withSchemaMigrationID(id int) schemamigrationOption {
	return func(m *SchemaMigrationMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemaMigration
		)
		m.oldValue = func(ctx context.Context) (*SchemaMigration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemaMigration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemaMigration sets the old SchemaMigration of the mutation.
func withSchemaMigration(node *SchemaMigration) schemamigrationOption {
	return func(m *SchemaMigrationMutation) {
		m.oldValue = func(context.Context) (*SchemaMigration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemaMigrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemaMigrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SchemaMigration entities.
func (m *SchemaMigrationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchemaMigrationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchemaMigrationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SchemaMigration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDirty sets the "dirty" field.
func (m *SchemaMigrationMutation) SetDirty(b bool) {
	m.dirty = &b
}

// Dirty returns the value of the "dirty" field in the mutation.
func (m *SchemaMigrationMutation) Dirty() (r bool, exists bool) {
	v := m.dirty
	if v == nil {
		return
	}
	return *v, true
}

// OldDirty returns the old "dirty" field's value of the SchemaMigration entity.
// If the SchemaMigration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaMigrationMutation) OldDirty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirty: %w", err)
	}
	return oldValue.Dirty, nil
}

// ResetDirty resets all changes to the "dirty" field.
func (m *SchemaMigrationMutation) ResetDirty() {
	m.dirty = nil
}

// Where appends a list predicates to the SchemaMigrationMutation builder.
func (m *SchemaMigrationMutation) Where(ps ...predicate.SchemaMigration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchemaMigrationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchemaMigrationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SchemaMigration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchemaMigrationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchemaMigrationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SchemaMigration).
func (m *SchemaMigrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchemaMigrationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.dirty != nil {
		fields = append(fields, schemamigration.FieldDirty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchemaMigrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemamigration.FieldDirty:
		return m.Dirty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchemaMigrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemamigration.FieldDirty:
		return m.OldDirty(ctx)
	}
	return nil, fmt.Errorf("unknown SchemaMigration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaMigrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemamigration.FieldDirty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirty(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaMigration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchemaMigrationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchemaMigrationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaMigrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SchemaMigration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchemaMigrationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchemaMigrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemaMigrationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SchemaMigration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchemaMigrationMutation) ResetField(name string) error {
	switch name {
	case schemamigration.FieldDirty:
		m.ResetDirty()
		return nil
	}
	return fmt.Errorf("unknown SchemaMigration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchemaMigrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchemaMigrationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchemaMigrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchemaMigrationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchemaMigrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchemaMigrationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchemaMigrationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SchemaMigration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchemaMigrationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SchemaMigration edge %s", name)
}

// TimeMutation represents an operation that mutates the Time nodes in the graph.
type TimeMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	date_time          *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	earthquakes        map[int]struct{}
	removedearthquakes map[int]struct{}
	clearedearthquakes bool
	done               bool
	oldValue           func(context.Context) (*Time, error)
	predicates         []predicate.Time
}

var _ ent.Mutation = (*TimeMutation)(nil)

// timeOption allows management of the mutation configuration using functional options.
type timeOption func(*TimeMutation)

// newTimeMutation creates new mutation for the Time entity.
func newTimeMutation(c config, op Op, opts ...timeOption) *TimeMutation {
	m := &TimeMutation{
		config:        c,
		op:            op,
		typ:           TypeTime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeID sets the ID field of the mutation.
func withTimeID(id int) timeOption {
	return func(m *TimeMutation) {
		var (
			err   error
			once  sync.Once
			value *Time
		)
		m.oldValue = func(ctx context.Context) (*Time, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Time.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTime sets the old Time of the mutation.
func withTime(node *Time) timeOption {
	return func(m *TimeMutation) {
		m.oldValue = func(context.Context) (*Time, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Time entities.
func (m *TimeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Time.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDateTime sets the "date_time" field.
func (m *TimeMutation) SetDateTime(t time.Time) {
	m.date_time = &t
}

// DateTime returns the value of the "date_time" field in the mutation.
func (m *TimeMutation) DateTime() (r time.Time, exists bool) {
	v := m.date_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old "date_time" field's value of the Time entity.
// If the Time object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeMutation) OldDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ClearDateTime clears the value of the "date_time" field.
func (m *TimeMutation) ClearDateTime() {
	m.date_time = nil
	m.clearedFields[enttime.FieldDateTime] = struct{}{}
}

// DateTimeCleared returns if the "date_time" field was cleared in this mutation.
func (m *TimeMutation) DateTimeCleared() bool {
	_, ok := m.clearedFields[enttime.FieldDateTime]
	return ok
}

// ResetDateTime resets all changes to the "date_time" field.
func (m *TimeMutation) ResetDateTime() {
	m.date_time = nil
	delete(m.clearedFields, enttime.FieldDateTime)
}

// SetCreatedAt sets the "created_at" field.
func (m *TimeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Time entity.
// If the Time object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TimeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[enttime.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TimeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[enttime.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, enttime.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TimeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TimeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Time entity.
// If the Time object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TimeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[enttime.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TimeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[enttime.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TimeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, enttime.FieldUpdatedAt)
}

// AddEarthquakeIDs adds the "earthquakes" edge to the Earthquake entity by ids.
func (m *TimeMutation) AddEarthquakeIDs(ids ...int) {
	if m.earthquakes == nil {
		m.earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.earthquakes[ids[i]] = struct{}{}
	}
}

// ClearEarthquakes clears the "earthquakes" edge to the Earthquake entity.
func (m *TimeMutation) ClearEarthquakes() {
	m.clearedearthquakes = true
}

// EarthquakesCleared reports if the "earthquakes" edge to the Earthquake entity was cleared.
func (m *TimeMutation) EarthquakesCleared() bool {
	return m.clearedearthquakes
}

// RemoveEarthquakeIDs removes the "earthquakes" edge to the Earthquake entity by IDs.
func (m *TimeMutation) RemoveEarthquakeIDs(ids ...int) {
	if m.removedearthquakes == nil {
		m.removedearthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.earthquakes, ids[i])
		m.removedearthquakes[ids[i]] = struct{}{}
	}
}

// RemovedEarthquakes returns the removed IDs of the "earthquakes" edge to the Earthquake entity.
func (m *TimeMutation) RemovedEarthquakesIDs() (ids []int) {
	for id := range m.removedearthquakes {
		ids = append(ids, id)
	}
	return
}

// EarthquakesIDs returns the "earthquakes" edge IDs in the mutation.
func (m *TimeMutation) EarthquakesIDs() (ids []int) {
	for id := range m.earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetEarthquakes resets all changes to the "earthquakes" edge.
func (m *TimeMutation) ResetEarthquakes() {
	m.earthquakes = nil
	m.clearedearthquakes = false
	m.removedearthquakes = nil
}

// Where appends a list predicates to the TimeMutation builder.
func (m *TimeMutation) Where(ps ...predicate.Time) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Time, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Time).
func (m *TimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.date_time != nil {
		fields = append(fields, enttime.FieldDateTime)
	}
	if m.created_at != nil {
		fields = append(fields, enttime.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enttime.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enttime.FieldDateTime:
		return m.DateTime()
	case enttime.FieldCreatedAt:
		return m.CreatedAt()
	case enttime.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enttime.FieldDateTime:
		return m.OldDateTime(ctx)
	case enttime.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enttime.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Time field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enttime.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	case enttime.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enttime.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Time field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Time numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enttime.FieldDateTime) {
		fields = append(fields, enttime.FieldDateTime)
	}
	if m.FieldCleared(enttime.FieldCreatedAt) {
		fields = append(fields, enttime.FieldCreatedAt)
	}
	if m.FieldCleared(enttime.FieldUpdatedAt) {
		fields = append(fields, enttime.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeMutation) ClearField(name string) error {
	switch name {
	case enttime.FieldDateTime:
		m.ClearDateTime()
		return nil
	case enttime.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case enttime.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Time nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeMutation) ResetField(name string) error {
	switch name {
	case enttime.FieldDateTime:
		m.ResetDateTime()
		return nil
	case enttime.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enttime.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Time field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquakes != nil {
		edges = append(edges, enttime.EdgeEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enttime.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.earthquakes))
		for id := range m.earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedearthquakes != nil {
		edges = append(edges, enttime.EdgeEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enttime.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedearthquakes))
		for id := range m.removedearthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquakes {
		edges = append(edges, enttime.EdgeEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeMutation) EdgeCleared(name string) bool {
	switch name {
	case enttime.EdgeEarthquakes:
		return m.clearedearthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Time unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeMutation) ResetEdge(name string) error {
	switch name {
	case enttime.EdgeEarthquakes:
		m.ResetEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown Time edge %s", name)
}

// TypeEathquakeMutation represents an operation that mutates the Type_eathquake nodes in the graph.
type TypeEathquakeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	type_eathquake    *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	earthquake        *int
	clearedearthquake bool
	done              bool
	oldValue          func(context.Context) (*Type_eathquake, error)
	predicates        []predicate.Type_eathquake
}

var _ ent.Mutation = (*TypeEathquakeMutation)(nil)

// typeEathquakeOption allows management of the mutation configuration using functional options.
type typeEathquakeOption func(*TypeEathquakeMutation)

// newTypeEathquakeMutation creates new mutation for the Type_eathquake entity.
func newTypeEathquakeMutation(c config, op Op, opts ...typeEathquakeOption) *TypeEathquakeMutation {
	m := &TypeEathquakeMutation{
		config:        c,
		op:            op,
		typ:           TypeTypeEathquake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withType_eathquakeID sets the ID field of the mutation.
func withType_eathquakeID(id int) typeEathquakeOption {
	return func(m *TypeEathquakeMutation) {
		var (
			err   error
			once  sync.Once
			value *Type_eathquake
		)
		m.oldValue = func(ctx context.Context) (*Type_eathquake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Type_eathquake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withType_eathquake sets the old Type_eathquake of the mutation.
func withType_eathquake(node *Type_eathquake) typeEathquakeOption {
	return func(m *TypeEathquakeMutation) {
		m.oldValue = func(context.Context) (*Type_eathquake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TypeEathquakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TypeEathquakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Type_eathquake entities.
func (m *TypeEathquakeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TypeEathquakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TypeEathquakeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Type_eathquake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEarthquakeID sets the "earthquake_id" field.
func (m *TypeEathquakeMutation) SetEarthquakeID(i int) {
	m.earthquake = &i
}

// EarthquakeID returns the value of the "earthquake_id" field in the mutation.
func (m *TypeEathquakeMutation) EarthquakeID() (r int, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEarthquakeID returns the old "earthquake_id" field's value of the Type_eathquake entity.
// If the Type_eathquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeEathquakeMutation) OldEarthquakeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEarthquakeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEarthquakeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarthquakeID: %w", err)
	}
	return oldValue.EarthquakeID, nil
}

// ClearEarthquakeID clears the value of the "earthquake_id" field.
func (m *TypeEathquakeMutation) ClearEarthquakeID() {
	m.earthquake = nil
	m.clearedFields[type_eathquake.FieldEarthquakeID] = struct{}{}
}

// EarthquakeIDCleared returns if the "earthquake_id" field was cleared in this mutation.
func (m *TypeEathquakeMutation) EarthquakeIDCleared() bool {
	_, ok := m.clearedFields[type_eathquake.FieldEarthquakeID]
	return ok
}

// ResetEarthquakeID resets all changes to the "earthquake_id" field.
func (m *TypeEathquakeMutation) ResetEarthquakeID() {
	m.earthquake = nil
	delete(m.clearedFields, type_eathquake.FieldEarthquakeID)
}

// SetTypeEathquake sets the "type_eathquake" field.
func (m *TypeEathquakeMutation) SetTypeEathquake(s string) {
	m.type_eathquake = &s
}

// TypeEathquake returns the value of the "type_eathquake" field in the mutation.
func (m *TypeEathquakeMutation) TypeEathquake() (r string, exists bool) {
	v := m.type_eathquake
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeEathquake returns the old "type_eathquake" field's value of the Type_eathquake entity.
// If the Type_eathquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeEathquakeMutation) OldTypeEathquake(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeEathquake is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeEathquake requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeEathquake: %w", err)
	}
	return oldValue.TypeEathquake, nil
}

// ClearTypeEathquake clears the value of the "type_eathquake" field.
func (m *TypeEathquakeMutation) ClearTypeEathquake() {
	m.type_eathquake = nil
	m.clearedFields[type_eathquake.FieldTypeEathquake] = struct{}{}
}

// TypeEathquakeCleared returns if the "type_eathquake" field was cleared in this mutation.
func (m *TypeEathquakeMutation) TypeEathquakeCleared() bool {
	_, ok := m.clearedFields[type_eathquake.FieldTypeEathquake]
	return ok
}

// ResetTypeEathquake resets all changes to the "type_eathquake" field.
func (m *TypeEathquakeMutation) ResetTypeEathquake() {
	m.type_eathquake = nil
	delete(m.clearedFields, type_eathquake.FieldTypeEathquake)
}

// SetCreatedAt sets the "created_at" field.
func (m *TypeEathquakeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TypeEathquakeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Type_eathquake entity.
// If the Type_eathquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeEathquakeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TypeEathquakeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[type_eathquake.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TypeEathquakeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[type_eathquake.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TypeEathquakeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, type_eathquake.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TypeEathquakeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TypeEathquakeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Type_eathquake entity.
// If the Type_eathquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeEathquakeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TypeEathquakeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[type_eathquake.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TypeEathquakeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[type_eathquake.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TypeEathquakeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, type_eathquake.FieldUpdatedAt)
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *TypeEathquakeMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[type_eathquake.FieldEarthquakeID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *TypeEathquakeMutation) EarthquakeCleared() bool {
	return m.EarthquakeIDCleared() || m.clearedearthquake
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *TypeEathquakeMutation) EarthquakeIDs() (ids []int) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *TypeEathquakeMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// Where appends a list predicates to the TypeEathquakeMutation builder.
func (m *TypeEathquakeMutation) Where(ps ...predicate.Type_eathquake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TypeEathquakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TypeEathquakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Type_eathquake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TypeEathquakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TypeEathquakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Type_eathquake).
func (m *TypeEathquakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TypeEathquakeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.earthquake != nil {
		fields = append(fields, type_eathquake.FieldEarthquakeID)
	}
	if m.type_eathquake != nil {
		fields = append(fields, type_eathquake.FieldTypeEathquake)
	}
	if m.created_at != nil {
		fields = append(fields, type_eathquake.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, type_eathquake.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TypeEathquakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case type_eathquake.FieldEarthquakeID:
		return m.EarthquakeID()
	case type_eathquake.FieldTypeEathquake:
		return m.TypeEathquake()
	case type_eathquake.FieldCreatedAt:
		return m.CreatedAt()
	case type_eathquake.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TypeEathquakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case type_eathquake.FieldEarthquakeID:
		return m.OldEarthquakeID(ctx)
	case type_eathquake.FieldTypeEathquake:
		return m.OldTypeEathquake(ctx)
	case type_eathquake.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case type_eathquake.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Type_eathquake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeEathquakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case type_eathquake.FieldEarthquakeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarthquakeID(v)
		return nil
	case type_eathquake.FieldTypeEathquake:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeEathquake(v)
		return nil
	case type_eathquake.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case type_eathquake.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Type_eathquake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TypeEathquakeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TypeEathquakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeEathquakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Type_eathquake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TypeEathquakeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(type_eathquake.FieldEarthquakeID) {
		fields = append(fields, type_eathquake.FieldEarthquakeID)
	}
	if m.FieldCleared(type_eathquake.FieldTypeEathquake) {
		fields = append(fields, type_eathquake.FieldTypeEathquake)
	}
	if m.FieldCleared(type_eathquake.FieldCreatedAt) {
		fields = append(fields, type_eathquake.FieldCreatedAt)
	}
	if m.FieldCleared(type_eathquake.FieldUpdatedAt) {
		fields = append(fields, type_eathquake.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TypeEathquakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TypeEathquakeMutation) ClearField(name string) error {
	switch name {
	case type_eathquake.FieldEarthquakeID:
		m.ClearEarthquakeID()
		return nil
	case type_eathquake.FieldTypeEathquake:
		m.ClearTypeEathquake()
		return nil
	case type_eathquake.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case type_eathquake.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Type_eathquake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TypeEathquakeMutation) ResetField(name string) error {
	switch name {
	case type_eathquake.FieldEarthquakeID:
		m.ResetEarthquakeID()
		return nil
	case type_eathquake.FieldTypeEathquake:
		m.ResetTypeEathquake()
		return nil
	case type_eathquake.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case type_eathquake.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Type_eathquake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TypeEathquakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquake != nil {
		edges = append(edges, type_eathquake.EdgeEarthquake)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TypeEathquakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case type_eathquake.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TypeEathquakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TypeEathquakeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TypeEathquakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquake {
		edges = append(edges, type_eathquake.EdgeEarthquake)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TypeEathquakeMutation) EdgeCleared(name string) bool {
	switch name {
	case type_eathquake.EdgeEarthquake:
		return m.clearedearthquake
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TypeEathquakeMutation) ClearEdge(name string) error {
	switch name {
	case type_eathquake.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	}
	return fmt.Errorf("unknown Type_eathquake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TypeEathquakeMutation) ResetEdge(name string) error {
	switch name {
	case type_eathquake.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	}
	return fmt.Errorf("unknown Type_eathquake edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	password      *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	role          *int
	clearedrole   bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *UserMutation) ClearRoleID() {
	m.role = nil
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *UserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role = nil
	delete(m.clearedFields, user.FieldRoleID)
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserMutation) RoleCleared() bool {
	return m.RoleIDCleared() || m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldRoleID) {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldRoleID:
		m.ClearRoleID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, user.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole {
		edges = append(edges, user.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
