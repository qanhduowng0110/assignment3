// Code generated by ent, DO NOT EDIT.

package ent

import (
	"assignment3/ent/associatedevent"
	"assignment3/ent/earthquake"
	"assignment3/ent/location"
	"assignment3/ent/magnitude"
	"assignment3/ent/predicate"
	enttime "assignment3/ent/time"
	"assignment3/ent/type_eathquake"
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// EarthquakeUpdate is the builder for updating Earthquake entities.
type EarthquakeUpdate struct {
	config
	hooks    []Hook
	mutation *EarthquakeMutation
}

// Where appends a list predicates to the EarthquakeUpdate builder.
func (eu *EarthquakeUpdate) Where(ps ...predicate.Earthquake) *EarthquakeUpdate {
	eu.mutation.Where(ps...)
	return eu
}

// SetLocationID sets the "location_id" field.
func (eu *EarthquakeUpdate) SetLocationID(i int) *EarthquakeUpdate {
	eu.mutation.SetLocationID(i)
	return eu
}

// SetNillableLocationID sets the "location_id" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableLocationID(i *int) *EarthquakeUpdate {
	if i != nil {
		eu.SetLocationID(*i)
	}
	return eu
}

// ClearLocationID clears the value of the "location_id" field.
func (eu *EarthquakeUpdate) ClearLocationID() *EarthquakeUpdate {
	eu.mutation.ClearLocationID()
	return eu
}

// SetTimeID sets the "time_id" field.
func (eu *EarthquakeUpdate) SetTimeID(i int) *EarthquakeUpdate {
	eu.mutation.SetTimeID(i)
	return eu
}

// SetNillableTimeID sets the "time_id" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableTimeID(i *int) *EarthquakeUpdate {
	if i != nil {
		eu.SetTimeID(*i)
	}
	return eu
}

// ClearTimeID clears the value of the "time_id" field.
func (eu *EarthquakeUpdate) ClearTimeID() *EarthquakeUpdate {
	eu.mutation.ClearTimeID()
	return eu
}

// SetMagitudeID sets the "magitude_id" field.
func (eu *EarthquakeUpdate) SetMagitudeID(i int) *EarthquakeUpdate {
	eu.mutation.SetMagitudeID(i)
	return eu
}

// SetNillableMagitudeID sets the "magitude_id" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableMagitudeID(i *int) *EarthquakeUpdate {
	if i != nil {
		eu.SetMagitudeID(*i)
	}
	return eu
}

// ClearMagitudeID clears the value of the "magitude_id" field.
func (eu *EarthquakeUpdate) ClearMagitudeID() *EarthquakeUpdate {
	eu.mutation.ClearMagitudeID()
	return eu
}

// SetURL sets the "url" field.
func (eu *EarthquakeUpdate) SetURL(s string) *EarthquakeUpdate {
	eu.mutation.SetURL(s)
	return eu
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableURL(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetURL(*s)
	}
	return eu
}

// ClearURL clears the value of the "url" field.
func (eu *EarthquakeUpdate) ClearURL() *EarthquakeUpdate {
	eu.mutation.ClearURL()
	return eu
}

// SetStatus sets the "status" field.
func (eu *EarthquakeUpdate) SetStatus(s string) *EarthquakeUpdate {
	eu.mutation.SetStatus(s)
	return eu
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableStatus(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetStatus(*s)
	}
	return eu
}

// ClearStatus clears the value of the "status" field.
func (eu *EarthquakeUpdate) ClearStatus() *EarthquakeUpdate {
	eu.mutation.ClearStatus()
	return eu
}

// SetTsunami sets the "tsunami" field.
func (eu *EarthquakeUpdate) SetTsunami(i int32) *EarthquakeUpdate {
	eu.mutation.ResetTsunami()
	eu.mutation.SetTsunami(i)
	return eu
}

// SetNillableTsunami sets the "tsunami" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableTsunami(i *int32) *EarthquakeUpdate {
	if i != nil {
		eu.SetTsunami(*i)
	}
	return eu
}

// AddTsunami adds i to the "tsunami" field.
func (eu *EarthquakeUpdate) AddTsunami(i int32) *EarthquakeUpdate {
	eu.mutation.AddTsunami(i)
	return eu
}

// ClearTsunami clears the value of the "tsunami" field.
func (eu *EarthquakeUpdate) ClearTsunami() *EarthquakeUpdate {
	eu.mutation.ClearTsunami()
	return eu
}

// SetNet sets the "net" field.
func (eu *EarthquakeUpdate) SetNet(s string) *EarthquakeUpdate {
	eu.mutation.SetNet(s)
	return eu
}

// SetNillableNet sets the "net" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableNet(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetNet(*s)
	}
	return eu
}

// ClearNet clears the value of the "net" field.
func (eu *EarthquakeUpdate) ClearNet() *EarthquakeUpdate {
	eu.mutation.ClearNet()
	return eu
}

// SetCode sets the "code" field.
func (eu *EarthquakeUpdate) SetCode(s string) *EarthquakeUpdate {
	eu.mutation.SetCode(s)
	return eu
}

// SetNillableCode sets the "code" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableCode(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetCode(*s)
	}
	return eu
}

// ClearCode clears the value of the "code" field.
func (eu *EarthquakeUpdate) ClearCode() *EarthquakeUpdate {
	eu.mutation.ClearCode()
	return eu
}

// SetSources sets the "sources" field.
func (eu *EarthquakeUpdate) SetSources(s string) *EarthquakeUpdate {
	eu.mutation.SetSources(s)
	return eu
}

// SetNillableSources sets the "sources" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableSources(s *string) *EarthquakeUpdate {
	if s != nil {
		eu.SetSources(*s)
	}
	return eu
}

// ClearSources clears the value of the "sources" field.
func (eu *EarthquakeUpdate) ClearSources() *EarthquakeUpdate {
	eu.mutation.ClearSources()
	return eu
}

// SetNst sets the "nst" field.
func (eu *EarthquakeUpdate) SetNst(i int) *EarthquakeUpdate {
	eu.mutation.ResetNst()
	eu.mutation.SetNst(i)
	return eu
}

// SetNillableNst sets the "nst" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableNst(i *int) *EarthquakeUpdate {
	if i != nil {
		eu.SetNst(*i)
	}
	return eu
}

// AddNst adds i to the "nst" field.
func (eu *EarthquakeUpdate) AddNst(i int) *EarthquakeUpdate {
	eu.mutation.AddNst(i)
	return eu
}

// ClearNst clears the value of the "nst" field.
func (eu *EarthquakeUpdate) ClearNst() *EarthquakeUpdate {
	eu.mutation.ClearNst()
	return eu
}

// SetDmin sets the "dmin" field.
func (eu *EarthquakeUpdate) SetDmin(f float64) *EarthquakeUpdate {
	eu.mutation.ResetDmin()
	eu.mutation.SetDmin(f)
	return eu
}

// SetNillableDmin sets the "dmin" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableDmin(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetDmin(*f)
	}
	return eu
}

// AddDmin adds f to the "dmin" field.
func (eu *EarthquakeUpdate) AddDmin(f float64) *EarthquakeUpdate {
	eu.mutation.AddDmin(f)
	return eu
}

// ClearDmin clears the value of the "dmin" field.
func (eu *EarthquakeUpdate) ClearDmin() *EarthquakeUpdate {
	eu.mutation.ClearDmin()
	return eu
}

// SetRms sets the "rms" field.
func (eu *EarthquakeUpdate) SetRms(f float64) *EarthquakeUpdate {
	eu.mutation.ResetRms()
	eu.mutation.SetRms(f)
	return eu
}

// SetNillableRms sets the "rms" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableRms(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetRms(*f)
	}
	return eu
}

// AddRms adds f to the "rms" field.
func (eu *EarthquakeUpdate) AddRms(f float64) *EarthquakeUpdate {
	eu.mutation.AddRms(f)
	return eu
}

// ClearRms clears the value of the "rms" field.
func (eu *EarthquakeUpdate) ClearRms() *EarthquakeUpdate {
	eu.mutation.ClearRms()
	return eu
}

// SetGap sets the "gap" field.
func (eu *EarthquakeUpdate) SetGap(f float64) *EarthquakeUpdate {
	eu.mutation.ResetGap()
	eu.mutation.SetGap(f)
	return eu
}

// SetNillableGap sets the "gap" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableGap(f *float64) *EarthquakeUpdate {
	if f != nil {
		eu.SetGap(*f)
	}
	return eu
}

// AddGap adds f to the "gap" field.
func (eu *EarthquakeUpdate) AddGap(f float64) *EarthquakeUpdate {
	eu.mutation.AddGap(f)
	return eu
}

// ClearGap clears the value of the "gap" field.
func (eu *EarthquakeUpdate) ClearGap() *EarthquakeUpdate {
	eu.mutation.ClearGap()
	return eu
}

// SetCreatedAt sets the "created_at" field.
func (eu *EarthquakeUpdate) SetCreatedAt(t time.Time) *EarthquakeUpdate {
	eu.mutation.SetCreatedAt(t)
	return eu
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableCreatedAt(t *time.Time) *EarthquakeUpdate {
	if t != nil {
		eu.SetCreatedAt(*t)
	}
	return eu
}

// ClearCreatedAt clears the value of the "created_at" field.
func (eu *EarthquakeUpdate) ClearCreatedAt() *EarthquakeUpdate {
	eu.mutation.ClearCreatedAt()
	return eu
}

// SetUpdatedAt sets the "updated_at" field.
func (eu *EarthquakeUpdate) SetUpdatedAt(t time.Time) *EarthquakeUpdate {
	eu.mutation.SetUpdatedAt(t)
	return eu
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableUpdatedAt(t *time.Time) *EarthquakeUpdate {
	if t != nil {
		eu.SetUpdatedAt(*t)
	}
	return eu
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (eu *EarthquakeUpdate) ClearUpdatedAt() *EarthquakeUpdate {
	eu.mutation.ClearUpdatedAt()
	return eu
}

// AddAssociatedEventIDs adds the "associated_events" edge to the AssociatedEvent entity by IDs.
func (eu *EarthquakeUpdate) AddAssociatedEventIDs(ids ...int) *EarthquakeUpdate {
	eu.mutation.AddAssociatedEventIDs(ids...)
	return eu
}

// AddAssociatedEvents adds the "associated_events" edges to the AssociatedEvent entity.
func (eu *EarthquakeUpdate) AddAssociatedEvents(a ...*AssociatedEvent) *EarthquakeUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return eu.AddAssociatedEventIDs(ids...)
}

// SetLocation sets the "location" edge to the Location entity.
func (eu *EarthquakeUpdate) SetLocation(l *Location) *EarthquakeUpdate {
	return eu.SetLocationID(l.ID)
}

// SetMagnitudeID sets the "magnitude" edge to the Magnitude entity by ID.
func (eu *EarthquakeUpdate) SetMagnitudeID(id int) *EarthquakeUpdate {
	eu.mutation.SetMagnitudeID(id)
	return eu
}

// SetNillableMagnitudeID sets the "magnitude" edge to the Magnitude entity by ID if the given value is not nil.
func (eu *EarthquakeUpdate) SetNillableMagnitudeID(id *int) *EarthquakeUpdate {
	if id != nil {
		eu = eu.SetMagnitudeID(*id)
	}
	return eu
}

// SetMagnitude sets the "magnitude" edge to the Magnitude entity.
func (eu *EarthquakeUpdate) SetMagnitude(m *Magnitude) *EarthquakeUpdate {
	return eu.SetMagnitudeID(m.ID)
}

// SetTime sets the "time" edge to the Time entity.
func (eu *EarthquakeUpdate) SetTime(t *Time) *EarthquakeUpdate {
	return eu.SetTimeID(t.ID)
}

// AddTypeIDs adds the "types" edge to the Type_eathquake entity by IDs.
func (eu *EarthquakeUpdate) AddTypeIDs(ids ...int) *EarthquakeUpdate {
	eu.mutation.AddTypeIDs(ids...)
	return eu
}

// AddTypes adds the "types" edges to the Type_eathquake entity.
func (eu *EarthquakeUpdate) AddTypes(t ...*Type_eathquake) *EarthquakeUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return eu.AddTypeIDs(ids...)
}

// Mutation returns the EarthquakeMutation object of the builder.
func (eu *EarthquakeUpdate) Mutation() *EarthquakeMutation {
	return eu.mutation
}

// ClearAssociatedEvents clears all "associated_events" edges to the AssociatedEvent entity.
func (eu *EarthquakeUpdate) ClearAssociatedEvents() *EarthquakeUpdate {
	eu.mutation.ClearAssociatedEvents()
	return eu
}

// RemoveAssociatedEventIDs removes the "associated_events" edge to AssociatedEvent entities by IDs.
func (eu *EarthquakeUpdate) RemoveAssociatedEventIDs(ids ...int) *EarthquakeUpdate {
	eu.mutation.RemoveAssociatedEventIDs(ids...)
	return eu
}

// RemoveAssociatedEvents removes "associated_events" edges to AssociatedEvent entities.
func (eu *EarthquakeUpdate) RemoveAssociatedEvents(a ...*AssociatedEvent) *EarthquakeUpdate {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return eu.RemoveAssociatedEventIDs(ids...)
}

// ClearLocation clears the "location" edge to the Location entity.
func (eu *EarthquakeUpdate) ClearLocation() *EarthquakeUpdate {
	eu.mutation.ClearLocation()
	return eu
}

// ClearMagnitude clears the "magnitude" edge to the Magnitude entity.
func (eu *EarthquakeUpdate) ClearMagnitude() *EarthquakeUpdate {
	eu.mutation.ClearMagnitude()
	return eu
}

// ClearTime clears the "time" edge to the Time entity.
func (eu *EarthquakeUpdate) ClearTime() *EarthquakeUpdate {
	eu.mutation.ClearTime()
	return eu
}

// ClearTypes clears all "types" edges to the Type_eathquake entity.
func (eu *EarthquakeUpdate) ClearTypes() *EarthquakeUpdate {
	eu.mutation.ClearTypes()
	return eu
}

// RemoveTypeIDs removes the "types" edge to Type_eathquake entities by IDs.
func (eu *EarthquakeUpdate) RemoveTypeIDs(ids ...int) *EarthquakeUpdate {
	eu.mutation.RemoveTypeIDs(ids...)
	return eu
}

// RemoveTypes removes "types" edges to Type_eathquake entities.
func (eu *EarthquakeUpdate) RemoveTypes(t ...*Type_eathquake) *EarthquakeUpdate {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return eu.RemoveTypeIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (eu *EarthquakeUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, eu.sqlSave, eu.mutation, eu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (eu *EarthquakeUpdate) SaveX(ctx context.Context) int {
	affected, err := eu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (eu *EarthquakeUpdate) Exec(ctx context.Context) error {
	_, err := eu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eu *EarthquakeUpdate) ExecX(ctx context.Context) {
	if err := eu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (eu *EarthquakeUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(earthquake.Table, earthquake.Columns, sqlgraph.NewFieldSpec(earthquake.FieldID, field.TypeInt))
	if ps := eu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := eu.mutation.URL(); ok {
		_spec.SetField(earthquake.FieldURL, field.TypeString, value)
	}
	if eu.mutation.URLCleared() {
		_spec.ClearField(earthquake.FieldURL, field.TypeString)
	}
	if value, ok := eu.mutation.Status(); ok {
		_spec.SetField(earthquake.FieldStatus, field.TypeString, value)
	}
	if eu.mutation.StatusCleared() {
		_spec.ClearField(earthquake.FieldStatus, field.TypeString)
	}
	if value, ok := eu.mutation.Tsunami(); ok {
		_spec.SetField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if value, ok := eu.mutation.AddedTsunami(); ok {
		_spec.AddField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if eu.mutation.TsunamiCleared() {
		_spec.ClearField(earthquake.FieldTsunami, field.TypeInt32)
	}
	if value, ok := eu.mutation.Net(); ok {
		_spec.SetField(earthquake.FieldNet, field.TypeString, value)
	}
	if eu.mutation.NetCleared() {
		_spec.ClearField(earthquake.FieldNet, field.TypeString)
	}
	if value, ok := eu.mutation.Code(); ok {
		_spec.SetField(earthquake.FieldCode, field.TypeString, value)
	}
	if eu.mutation.CodeCleared() {
		_spec.ClearField(earthquake.FieldCode, field.TypeString)
	}
	if value, ok := eu.mutation.Sources(); ok {
		_spec.SetField(earthquake.FieldSources, field.TypeString, value)
	}
	if eu.mutation.SourcesCleared() {
		_spec.ClearField(earthquake.FieldSources, field.TypeString)
	}
	if value, ok := eu.mutation.Nst(); ok {
		_spec.SetField(earthquake.FieldNst, field.TypeInt, value)
	}
	if value, ok := eu.mutation.AddedNst(); ok {
		_spec.AddField(earthquake.FieldNst, field.TypeInt, value)
	}
	if eu.mutation.NstCleared() {
		_spec.ClearField(earthquake.FieldNst, field.TypeInt)
	}
	if value, ok := eu.mutation.Dmin(); ok {
		_spec.SetField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedDmin(); ok {
		_spec.AddField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if eu.mutation.DminCleared() {
		_spec.ClearField(earthquake.FieldDmin, field.TypeFloat64)
	}
	if value, ok := eu.mutation.Rms(); ok {
		_spec.SetField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedRms(); ok {
		_spec.AddField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if eu.mutation.RmsCleared() {
		_spec.ClearField(earthquake.FieldRms, field.TypeFloat64)
	}
	if value, ok := eu.mutation.Gap(); ok {
		_spec.SetField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if value, ok := eu.mutation.AddedGap(); ok {
		_spec.AddField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if eu.mutation.GapCleared() {
		_spec.ClearField(earthquake.FieldGap, field.TypeFloat64)
	}
	if value, ok := eu.mutation.CreatedAt(); ok {
		_spec.SetField(earthquake.FieldCreatedAt, field.TypeTime, value)
	}
	if eu.mutation.CreatedAtCleared() {
		_spec.ClearField(earthquake.FieldCreatedAt, field.TypeTime)
	}
	if value, ok := eu.mutation.UpdatedAt(); ok {
		_spec.SetField(earthquake.FieldUpdatedAt, field.TypeTime, value)
	}
	if eu.mutation.UpdatedAtCleared() {
		_spec.ClearField(earthquake.FieldUpdatedAt, field.TypeTime)
	}
	if eu.mutation.AssociatedEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedAssociatedEventsIDs(); len(nodes) > 0 && !eu.mutation.AssociatedEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.AssociatedEventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.LocationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.LocationTable,
			Columns: []string{earthquake.LocationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(location.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.LocationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.LocationTable,
			Columns: []string{earthquake.LocationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(location.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.MagnitudeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.MagnitudeTable,
			Columns: []string{earthquake.MagnitudeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(magnitude.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.MagnitudeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.MagnitudeTable,
			Columns: []string{earthquake.MagnitudeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(magnitude.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.TimeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.TimeTable,
			Columns: []string{earthquake.TimeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(enttime.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.TimeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.TimeTable,
			Columns: []string{earthquake.TimeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(enttime.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if eu.mutation.TypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.TypesTable,
			Columns: []string{earthquake.TypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(type_eathquake.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.RemovedTypesIDs(); len(nodes) > 0 && !eu.mutation.TypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.TypesTable,
			Columns: []string{earthquake.TypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(type_eathquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eu.mutation.TypesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.TypesTable,
			Columns: []string{earthquake.TypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(type_eathquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, eu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{earthquake.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	eu.mutation.done = true
	return n, nil
}

// EarthquakeUpdateOne is the builder for updating a single Earthquake entity.
type EarthquakeUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *EarthquakeMutation
}

// SetLocationID sets the "location_id" field.
func (euo *EarthquakeUpdateOne) SetLocationID(i int) *EarthquakeUpdateOne {
	euo.mutation.SetLocationID(i)
	return euo
}

// SetNillableLocationID sets the "location_id" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableLocationID(i *int) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetLocationID(*i)
	}
	return euo
}

// ClearLocationID clears the value of the "location_id" field.
func (euo *EarthquakeUpdateOne) ClearLocationID() *EarthquakeUpdateOne {
	euo.mutation.ClearLocationID()
	return euo
}

// SetTimeID sets the "time_id" field.
func (euo *EarthquakeUpdateOne) SetTimeID(i int) *EarthquakeUpdateOne {
	euo.mutation.SetTimeID(i)
	return euo
}

// SetNillableTimeID sets the "time_id" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableTimeID(i *int) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetTimeID(*i)
	}
	return euo
}

// ClearTimeID clears the value of the "time_id" field.
func (euo *EarthquakeUpdateOne) ClearTimeID() *EarthquakeUpdateOne {
	euo.mutation.ClearTimeID()
	return euo
}

// SetMagitudeID sets the "magitude_id" field.
func (euo *EarthquakeUpdateOne) SetMagitudeID(i int) *EarthquakeUpdateOne {
	euo.mutation.SetMagitudeID(i)
	return euo
}

// SetNillableMagitudeID sets the "magitude_id" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableMagitudeID(i *int) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetMagitudeID(*i)
	}
	return euo
}

// ClearMagitudeID clears the value of the "magitude_id" field.
func (euo *EarthquakeUpdateOne) ClearMagitudeID() *EarthquakeUpdateOne {
	euo.mutation.ClearMagitudeID()
	return euo
}

// SetURL sets the "url" field.
func (euo *EarthquakeUpdateOne) SetURL(s string) *EarthquakeUpdateOne {
	euo.mutation.SetURL(s)
	return euo
}

// SetNillableURL sets the "url" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableURL(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetURL(*s)
	}
	return euo
}

// ClearURL clears the value of the "url" field.
func (euo *EarthquakeUpdateOne) ClearURL() *EarthquakeUpdateOne {
	euo.mutation.ClearURL()
	return euo
}

// SetStatus sets the "status" field.
func (euo *EarthquakeUpdateOne) SetStatus(s string) *EarthquakeUpdateOne {
	euo.mutation.SetStatus(s)
	return euo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableStatus(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetStatus(*s)
	}
	return euo
}

// ClearStatus clears the value of the "status" field.
func (euo *EarthquakeUpdateOne) ClearStatus() *EarthquakeUpdateOne {
	euo.mutation.ClearStatus()
	return euo
}

// SetTsunami sets the "tsunami" field.
func (euo *EarthquakeUpdateOne) SetTsunami(i int32) *EarthquakeUpdateOne {
	euo.mutation.ResetTsunami()
	euo.mutation.SetTsunami(i)
	return euo
}

// SetNillableTsunami sets the "tsunami" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableTsunami(i *int32) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetTsunami(*i)
	}
	return euo
}

// AddTsunami adds i to the "tsunami" field.
func (euo *EarthquakeUpdateOne) AddTsunami(i int32) *EarthquakeUpdateOne {
	euo.mutation.AddTsunami(i)
	return euo
}

// ClearTsunami clears the value of the "tsunami" field.
func (euo *EarthquakeUpdateOne) ClearTsunami() *EarthquakeUpdateOne {
	euo.mutation.ClearTsunami()
	return euo
}

// SetNet sets the "net" field.
func (euo *EarthquakeUpdateOne) SetNet(s string) *EarthquakeUpdateOne {
	euo.mutation.SetNet(s)
	return euo
}

// SetNillableNet sets the "net" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableNet(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetNet(*s)
	}
	return euo
}

// ClearNet clears the value of the "net" field.
func (euo *EarthquakeUpdateOne) ClearNet() *EarthquakeUpdateOne {
	euo.mutation.ClearNet()
	return euo
}

// SetCode sets the "code" field.
func (euo *EarthquakeUpdateOne) SetCode(s string) *EarthquakeUpdateOne {
	euo.mutation.SetCode(s)
	return euo
}

// SetNillableCode sets the "code" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableCode(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetCode(*s)
	}
	return euo
}

// ClearCode clears the value of the "code" field.
func (euo *EarthquakeUpdateOne) ClearCode() *EarthquakeUpdateOne {
	euo.mutation.ClearCode()
	return euo
}

// SetSources sets the "sources" field.
func (euo *EarthquakeUpdateOne) SetSources(s string) *EarthquakeUpdateOne {
	euo.mutation.SetSources(s)
	return euo
}

// SetNillableSources sets the "sources" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableSources(s *string) *EarthquakeUpdateOne {
	if s != nil {
		euo.SetSources(*s)
	}
	return euo
}

// ClearSources clears the value of the "sources" field.
func (euo *EarthquakeUpdateOne) ClearSources() *EarthquakeUpdateOne {
	euo.mutation.ClearSources()
	return euo
}

// SetNst sets the "nst" field.
func (euo *EarthquakeUpdateOne) SetNst(i int) *EarthquakeUpdateOne {
	euo.mutation.ResetNst()
	euo.mutation.SetNst(i)
	return euo
}

// SetNillableNst sets the "nst" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableNst(i *int) *EarthquakeUpdateOne {
	if i != nil {
		euo.SetNst(*i)
	}
	return euo
}

// AddNst adds i to the "nst" field.
func (euo *EarthquakeUpdateOne) AddNst(i int) *EarthquakeUpdateOne {
	euo.mutation.AddNst(i)
	return euo
}

// ClearNst clears the value of the "nst" field.
func (euo *EarthquakeUpdateOne) ClearNst() *EarthquakeUpdateOne {
	euo.mutation.ClearNst()
	return euo
}

// SetDmin sets the "dmin" field.
func (euo *EarthquakeUpdateOne) SetDmin(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetDmin()
	euo.mutation.SetDmin(f)
	return euo
}

// SetNillableDmin sets the "dmin" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableDmin(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetDmin(*f)
	}
	return euo
}

// AddDmin adds f to the "dmin" field.
func (euo *EarthquakeUpdateOne) AddDmin(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddDmin(f)
	return euo
}

// ClearDmin clears the value of the "dmin" field.
func (euo *EarthquakeUpdateOne) ClearDmin() *EarthquakeUpdateOne {
	euo.mutation.ClearDmin()
	return euo
}

// SetRms sets the "rms" field.
func (euo *EarthquakeUpdateOne) SetRms(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetRms()
	euo.mutation.SetRms(f)
	return euo
}

// SetNillableRms sets the "rms" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableRms(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetRms(*f)
	}
	return euo
}

// AddRms adds f to the "rms" field.
func (euo *EarthquakeUpdateOne) AddRms(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddRms(f)
	return euo
}

// ClearRms clears the value of the "rms" field.
func (euo *EarthquakeUpdateOne) ClearRms() *EarthquakeUpdateOne {
	euo.mutation.ClearRms()
	return euo
}

// SetGap sets the "gap" field.
func (euo *EarthquakeUpdateOne) SetGap(f float64) *EarthquakeUpdateOne {
	euo.mutation.ResetGap()
	euo.mutation.SetGap(f)
	return euo
}

// SetNillableGap sets the "gap" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableGap(f *float64) *EarthquakeUpdateOne {
	if f != nil {
		euo.SetGap(*f)
	}
	return euo
}

// AddGap adds f to the "gap" field.
func (euo *EarthquakeUpdateOne) AddGap(f float64) *EarthquakeUpdateOne {
	euo.mutation.AddGap(f)
	return euo
}

// ClearGap clears the value of the "gap" field.
func (euo *EarthquakeUpdateOne) ClearGap() *EarthquakeUpdateOne {
	euo.mutation.ClearGap()
	return euo
}

// SetCreatedAt sets the "created_at" field.
func (euo *EarthquakeUpdateOne) SetCreatedAt(t time.Time) *EarthquakeUpdateOne {
	euo.mutation.SetCreatedAt(t)
	return euo
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableCreatedAt(t *time.Time) *EarthquakeUpdateOne {
	if t != nil {
		euo.SetCreatedAt(*t)
	}
	return euo
}

// ClearCreatedAt clears the value of the "created_at" field.
func (euo *EarthquakeUpdateOne) ClearCreatedAt() *EarthquakeUpdateOne {
	euo.mutation.ClearCreatedAt()
	return euo
}

// SetUpdatedAt sets the "updated_at" field.
func (euo *EarthquakeUpdateOne) SetUpdatedAt(t time.Time) *EarthquakeUpdateOne {
	euo.mutation.SetUpdatedAt(t)
	return euo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableUpdatedAt(t *time.Time) *EarthquakeUpdateOne {
	if t != nil {
		euo.SetUpdatedAt(*t)
	}
	return euo
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (euo *EarthquakeUpdateOne) ClearUpdatedAt() *EarthquakeUpdateOne {
	euo.mutation.ClearUpdatedAt()
	return euo
}

// AddAssociatedEventIDs adds the "associated_events" edge to the AssociatedEvent entity by IDs.
func (euo *EarthquakeUpdateOne) AddAssociatedEventIDs(ids ...int) *EarthquakeUpdateOne {
	euo.mutation.AddAssociatedEventIDs(ids...)
	return euo
}

// AddAssociatedEvents adds the "associated_events" edges to the AssociatedEvent entity.
func (euo *EarthquakeUpdateOne) AddAssociatedEvents(a ...*AssociatedEvent) *EarthquakeUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return euo.AddAssociatedEventIDs(ids...)
}

// SetLocation sets the "location" edge to the Location entity.
func (euo *EarthquakeUpdateOne) SetLocation(l *Location) *EarthquakeUpdateOne {
	return euo.SetLocationID(l.ID)
}

// SetMagnitudeID sets the "magnitude" edge to the Magnitude entity by ID.
func (euo *EarthquakeUpdateOne) SetMagnitudeID(id int) *EarthquakeUpdateOne {
	euo.mutation.SetMagnitudeID(id)
	return euo
}

// SetNillableMagnitudeID sets the "magnitude" edge to the Magnitude entity by ID if the given value is not nil.
func (euo *EarthquakeUpdateOne) SetNillableMagnitudeID(id *int) *EarthquakeUpdateOne {
	if id != nil {
		euo = euo.SetMagnitudeID(*id)
	}
	return euo
}

// SetMagnitude sets the "magnitude" edge to the Magnitude entity.
func (euo *EarthquakeUpdateOne) SetMagnitude(m *Magnitude) *EarthquakeUpdateOne {
	return euo.SetMagnitudeID(m.ID)
}

// SetTime sets the "time" edge to the Time entity.
func (euo *EarthquakeUpdateOne) SetTime(t *Time) *EarthquakeUpdateOne {
	return euo.SetTimeID(t.ID)
}

// AddTypeIDs adds the "types" edge to the Type_eathquake entity by IDs.
func (euo *EarthquakeUpdateOne) AddTypeIDs(ids ...int) *EarthquakeUpdateOne {
	euo.mutation.AddTypeIDs(ids...)
	return euo
}

// AddTypes adds the "types" edges to the Type_eathquake entity.
func (euo *EarthquakeUpdateOne) AddTypes(t ...*Type_eathquake) *EarthquakeUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return euo.AddTypeIDs(ids...)
}

// Mutation returns the EarthquakeMutation object of the builder.
func (euo *EarthquakeUpdateOne) Mutation() *EarthquakeMutation {
	return euo.mutation
}

// ClearAssociatedEvents clears all "associated_events" edges to the AssociatedEvent entity.
func (euo *EarthquakeUpdateOne) ClearAssociatedEvents() *EarthquakeUpdateOne {
	euo.mutation.ClearAssociatedEvents()
	return euo
}

// RemoveAssociatedEventIDs removes the "associated_events" edge to AssociatedEvent entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveAssociatedEventIDs(ids ...int) *EarthquakeUpdateOne {
	euo.mutation.RemoveAssociatedEventIDs(ids...)
	return euo
}

// RemoveAssociatedEvents removes "associated_events" edges to AssociatedEvent entities.
func (euo *EarthquakeUpdateOne) RemoveAssociatedEvents(a ...*AssociatedEvent) *EarthquakeUpdateOne {
	ids := make([]int, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return euo.RemoveAssociatedEventIDs(ids...)
}

// ClearLocation clears the "location" edge to the Location entity.
func (euo *EarthquakeUpdateOne) ClearLocation() *EarthquakeUpdateOne {
	euo.mutation.ClearLocation()
	return euo
}

// ClearMagnitude clears the "magnitude" edge to the Magnitude entity.
func (euo *EarthquakeUpdateOne) ClearMagnitude() *EarthquakeUpdateOne {
	euo.mutation.ClearMagnitude()
	return euo
}

// ClearTime clears the "time" edge to the Time entity.
func (euo *EarthquakeUpdateOne) ClearTime() *EarthquakeUpdateOne {
	euo.mutation.ClearTime()
	return euo
}

// ClearTypes clears all "types" edges to the Type_eathquake entity.
func (euo *EarthquakeUpdateOne) ClearTypes() *EarthquakeUpdateOne {
	euo.mutation.ClearTypes()
	return euo
}

// RemoveTypeIDs removes the "types" edge to Type_eathquake entities by IDs.
func (euo *EarthquakeUpdateOne) RemoveTypeIDs(ids ...int) *EarthquakeUpdateOne {
	euo.mutation.RemoveTypeIDs(ids...)
	return euo
}

// RemoveTypes removes "types" edges to Type_eathquake entities.
func (euo *EarthquakeUpdateOne) RemoveTypes(t ...*Type_eathquake) *EarthquakeUpdateOne {
	ids := make([]int, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return euo.RemoveTypeIDs(ids...)
}

// Where appends a list predicates to the EarthquakeUpdate builder.
func (euo *EarthquakeUpdateOne) Where(ps ...predicate.Earthquake) *EarthquakeUpdateOne {
	euo.mutation.Where(ps...)
	return euo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (euo *EarthquakeUpdateOne) Select(field string, fields ...string) *EarthquakeUpdateOne {
	euo.fields = append([]string{field}, fields...)
	return euo
}

// Save executes the query and returns the updated Earthquake entity.
func (euo *EarthquakeUpdateOne) Save(ctx context.Context) (*Earthquake, error) {
	return withHooks(ctx, euo.sqlSave, euo.mutation, euo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (euo *EarthquakeUpdateOne) SaveX(ctx context.Context) *Earthquake {
	node, err := euo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (euo *EarthquakeUpdateOne) Exec(ctx context.Context) error {
	_, err := euo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (euo *EarthquakeUpdateOne) ExecX(ctx context.Context) {
	if err := euo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (euo *EarthquakeUpdateOne) sqlSave(ctx context.Context) (_node *Earthquake, err error) {
	_spec := sqlgraph.NewUpdateSpec(earthquake.Table, earthquake.Columns, sqlgraph.NewFieldSpec(earthquake.FieldID, field.TypeInt))
	id, ok := euo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Earthquake.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := euo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, earthquake.FieldID)
		for _, f := range fields {
			if !earthquake.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != earthquake.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := euo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := euo.mutation.URL(); ok {
		_spec.SetField(earthquake.FieldURL, field.TypeString, value)
	}
	if euo.mutation.URLCleared() {
		_spec.ClearField(earthquake.FieldURL, field.TypeString)
	}
	if value, ok := euo.mutation.Status(); ok {
		_spec.SetField(earthquake.FieldStatus, field.TypeString, value)
	}
	if euo.mutation.StatusCleared() {
		_spec.ClearField(earthquake.FieldStatus, field.TypeString)
	}
	if value, ok := euo.mutation.Tsunami(); ok {
		_spec.SetField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if value, ok := euo.mutation.AddedTsunami(); ok {
		_spec.AddField(earthquake.FieldTsunami, field.TypeInt32, value)
	}
	if euo.mutation.TsunamiCleared() {
		_spec.ClearField(earthquake.FieldTsunami, field.TypeInt32)
	}
	if value, ok := euo.mutation.Net(); ok {
		_spec.SetField(earthquake.FieldNet, field.TypeString, value)
	}
	if euo.mutation.NetCleared() {
		_spec.ClearField(earthquake.FieldNet, field.TypeString)
	}
	if value, ok := euo.mutation.Code(); ok {
		_spec.SetField(earthquake.FieldCode, field.TypeString, value)
	}
	if euo.mutation.CodeCleared() {
		_spec.ClearField(earthquake.FieldCode, field.TypeString)
	}
	if value, ok := euo.mutation.Sources(); ok {
		_spec.SetField(earthquake.FieldSources, field.TypeString, value)
	}
	if euo.mutation.SourcesCleared() {
		_spec.ClearField(earthquake.FieldSources, field.TypeString)
	}
	if value, ok := euo.mutation.Nst(); ok {
		_spec.SetField(earthquake.FieldNst, field.TypeInt, value)
	}
	if value, ok := euo.mutation.AddedNst(); ok {
		_spec.AddField(earthquake.FieldNst, field.TypeInt, value)
	}
	if euo.mutation.NstCleared() {
		_spec.ClearField(earthquake.FieldNst, field.TypeInt)
	}
	if value, ok := euo.mutation.Dmin(); ok {
		_spec.SetField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedDmin(); ok {
		_spec.AddField(earthquake.FieldDmin, field.TypeFloat64, value)
	}
	if euo.mutation.DminCleared() {
		_spec.ClearField(earthquake.FieldDmin, field.TypeFloat64)
	}
	if value, ok := euo.mutation.Rms(); ok {
		_spec.SetField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedRms(); ok {
		_spec.AddField(earthquake.FieldRms, field.TypeFloat64, value)
	}
	if euo.mutation.RmsCleared() {
		_spec.ClearField(earthquake.FieldRms, field.TypeFloat64)
	}
	if value, ok := euo.mutation.Gap(); ok {
		_spec.SetField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if value, ok := euo.mutation.AddedGap(); ok {
		_spec.AddField(earthquake.FieldGap, field.TypeFloat64, value)
	}
	if euo.mutation.GapCleared() {
		_spec.ClearField(earthquake.FieldGap, field.TypeFloat64)
	}
	if value, ok := euo.mutation.CreatedAt(); ok {
		_spec.SetField(earthquake.FieldCreatedAt, field.TypeTime, value)
	}
	if euo.mutation.CreatedAtCleared() {
		_spec.ClearField(earthquake.FieldCreatedAt, field.TypeTime)
	}
	if value, ok := euo.mutation.UpdatedAt(); ok {
		_spec.SetField(earthquake.FieldUpdatedAt, field.TypeTime, value)
	}
	if euo.mutation.UpdatedAtCleared() {
		_spec.ClearField(earthquake.FieldUpdatedAt, field.TypeTime)
	}
	if euo.mutation.AssociatedEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedAssociatedEventsIDs(); len(nodes) > 0 && !euo.mutation.AssociatedEventsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.AssociatedEventsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.AssociatedEventsTable,
			Columns: []string{earthquake.AssociatedEventsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(associatedevent.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.LocationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.LocationTable,
			Columns: []string{earthquake.LocationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(location.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.LocationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.LocationTable,
			Columns: []string{earthquake.LocationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(location.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.MagnitudeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.MagnitudeTable,
			Columns: []string{earthquake.MagnitudeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(magnitude.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.MagnitudeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.MagnitudeTable,
			Columns: []string{earthquake.MagnitudeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(magnitude.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.TimeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.TimeTable,
			Columns: []string{earthquake.TimeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(enttime.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.TimeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   earthquake.TimeTable,
			Columns: []string{earthquake.TimeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(enttime.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if euo.mutation.TypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.TypesTable,
			Columns: []string{earthquake.TypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(type_eathquake.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.RemovedTypesIDs(); len(nodes) > 0 && !euo.mutation.TypesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.TypesTable,
			Columns: []string{earthquake.TypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(type_eathquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := euo.mutation.TypesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   earthquake.TypesTable,
			Columns: []string{earthquake.TypesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(type_eathquake.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Earthquake{config: euo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, euo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{earthquake.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	euo.mutation.done = true
	return _node, nil
}
